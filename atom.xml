<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挽留之王小石</title>
  <icon>https://www.gravatar.com/avatar/a23107e3958da4844989715e80058f71</icon>
  <subtitle>Hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.juphy.com/"/>
  <updated>2018-08-14T03:23:45.787Z</updated>
  <id>http://blog.juphy.com/</id>
  
  <author>
    <name>Juphy</name>
    <email>gaojuphy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nodejs获取请求参数的方式</title>
    <link href="http://blog.juphy.com/2018/08/14/nodejs%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.juphy.com/2018/08/14/nodejs获取请求参数的方式/</id>
    <published>2018-08-14T03:22:00.000Z</published>
    <updated>2018-08-14T03:23:45.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs接收get请求参数"><a href="#nodejs接收get请求参数" class="headerlink" title="nodejs接收get请求参数"></a>nodejs接收get请求参数</h2><p>在http协议中，一个完整的url路径如下：</p><p><img src="http://ww1.sinaimg.cn/large/8b2b1aafly1fu91lq2nqaj20se0ebq3a.jpg" alt="完整的url路径"></p><p>get请求的参数是直接在url路径中显示的，在path资源路径的后面添加，以？表示参数的开始，以key = value表示参数的键值对，多个参数以&amp;符号分割，hash表示的是资源定位符，由浏览器自己解析处理。</p><p>浏览器向服务端发送get请求主要有两种方式，一种是href跳转，url拼接参数；一种是ajax请求发送参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let app = http.createServer();</span><br><span class="line">app.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line"></span><br><span class="line">    //1.默认情况下，如果url路径中有中文，则会对中文进行URI编码，所以服务端要想获取中文需要对url进行URI解码</span><br><span class="line">    console.log(encodeURI(req.url));</span><br><span class="line">    // 2.url.parse 方法可以将一个 URL 路径解析为一个方便操作的对象</span><br><span class="line">    // 将第二个可选参数指定为 true， 表示将结果中的 query 解析为一个对象</span><br><span class="line">    var parseObj = url.parse(req.url, true);</span><br><span class="line">    console.log(parseObj);</span><br><span class="line">    var pathname = parseObj.pathname; //相当于无参数的url路径</span><br><span class="line">    console.log(pathname);</span><br><span class="line">    // 这里将解析拿到的查询字符串对象作为一个属性挂载给 req 对象，这样的话在后续的代码中就可以直接通过 req.query 来获取查询字符串了</span><br><span class="line">    req.query = parseObj.query;</span><br><span class="line">    console.log(req.query);</span><br><span class="line">    if (pathname === &apos;/heroAdd&apos;) &#123;</span><br><span class="line">        fs.readFile(&apos;./heroAdd.html&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (pathname.indexOf(&apos;/node_modules&apos;) === 0) &#123;</span><br><span class="line">        fs.readFile(__dirname + pathname, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res.end(&apos;请求路径： &apos; + req.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="nodejs接收post请求参数"><a href="#nodejs接收post请求参数" class="headerlink" title="nodejs接收post请求参数"></a>nodejs接收post请求参数</h2><p>post请求参数不直接在url路径中拼接，而是放在请求体中发送给服务器，请求三要素：请求行、请求头、请求体。</p><p>与get请求不同的是，服务端接收post请求参数不是一次就可以获取的，通常需要多次。</p><h3 id="服务端接收表单数据"><a href="#服务端接收表单数据" class="headerlink" title="服务端接收表单数据"></a>服务端接收表单数据</h3><ul><li>(1)如果表单数据量越多，则发送的次数越多，如果比较少，可能一次就发过来了</li><li>(2)接收表单数据的时候，需要通过监听 req 对象的 data 事件来取数据</li><li>(3)每当收到一段表单提交过来的数据，req 的 data 事件就会被触发一次，同时通过回调函数可以拿到该 段 的数据<br>服务端需要自己添加数据流</li><li>(4)当接收表单提交的数据完毕之后，会执行req的 on 事件</li></ul><h3 id="服务端处理表单数据"><a href="#服务端处理表单数据" class="headerlink" title="服务端处理表单数据"></a>服务端处理表单数据</h3><ul><li>(1) 对数据进行解码（中文数据提交会进行url编码）decodeURI(data)</li><li>(2) 使用querystring对url进行反序列化（解析url将&amp;和=拆分成键值对），得到一个对象。</li><li>(3) 将数据插入到数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//1.导入http模块</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">//导入文件模块</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">//导入路径模块</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">//导入querystring模块（解析post请求数据）</span><br><span class="line">var querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">//2.创建服务器</span><br><span class="line">var app = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.添加响应事件</span><br><span class="line">app.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(req.method);</span><br><span class="line"></span><br><span class="line">    //1.通过判断url路径和请求方式来判断是否是表单提交</span><br><span class="line">    if (req.url === &apos;/heroAdd&apos; &amp;&amp; req.method === &apos;POST&apos;) &#123;</span><br><span class="line">        /**服务端接收post请求参数的流程</span><br><span class="line">         * （1）给req请求注册接收数据data事件（该方法会执行多次，需要我们手动累加二进制数据）</span><br><span class="line">         *      * 如果表单数据量越多，则发送的次数越多，如果比较少，可能一次就发过来了</span><br><span class="line">         *      * 所以接收表单数据的时候，需要通过监听 req 对象的 data 事件来取数据</span><br><span class="line">         *      * 也就是说，每当收到一段表单提交过来的数据，req 的 data 事件就会被触发一次，同时通过回调函数可以拿到该 段 的数据</span><br><span class="line">         * （2）给req请求注册完成接收数据end事件（所有数据接收完成会执行一次该方法）</span><br><span class="line">         */</span><br><span class="line">        //创建空字符叠加数据片段</span><br><span class="line">        var data = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        //2.注册data事件接收数据（每当收到一段表单提交的数据，该方法会执行一次）</span><br><span class="line">        req.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">            // chunk 默认是一个二进制数据，和 data 拼接会自动 toString</span><br><span class="line">            data += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 3.当接收表单提交的数据完毕之后，就可以进一步处理了</span><br><span class="line">        //注册end事件，所有数据接收完成会执行一次该方法</span><br><span class="line">        req.on(&apos;end&apos;, function () &#123;</span><br><span class="line"></span><br><span class="line">            //（1）.对url进行解码（url会对中文进行编码）</span><br><span class="line">            data = decodeURI(data);</span><br><span class="line">            console.log(data);</span><br><span class="line"></span><br><span class="line">            /**post请求参数不能使用url模块解析，因为他不是一个url，而是一个请求体对象 */</span><br><span class="line"></span><br><span class="line">            //（2）.使用querystring对url进行反序列化（解析url将&amp;和=拆分成键值对），得到一个对象</span><br><span class="line">            //querystring是nodejs内置的一个专用于处理url的模块，API只有四个，详情见nodejs官方文档</span><br><span class="line">            var dataObject = querystring.parse(data);</span><br><span class="line">            console.log(dataObject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (req.url === &apos;/heroAdd&apos; &amp;&amp; req.method === &apos;POST&apos;) &#123;</span><br><span class="line">        fs.readFile(&apos;./heroAdd.html&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (req.url.indexOf(&apos;/node_modules&apos;) === 0) &#123;</span><br><span class="line">        fs.readFile(__dirname + req.url, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res.end(&apos;请求路径： &apos; + req.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.监听端口号</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="nodejs使用express框架获取参数的方式"><a href="#nodejs使用express框架获取参数的方式" class="headerlink" title="nodejs使用express框架获取参数的方式"></a>nodejs使用express框架获取参数的方式</h2><h3 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h3><p>命名过的参数会以键值对的形式存放，路由<code>/user/:name</code>，浏览器访问<code>/user/a</code>，a值即name的属性会存放在req.params.name；如果有多个参数<code>/find/:group/:name</code>，浏览器访问<code>find/a/b</code>，<code>a=req.params.group</code>和<code>b=req.params.name</code>分别获取group和name的两个参数。</p><h3 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h3><p><code>/user/?id=1</code>，req.query.id会得到1，如果有两个或者两个以上的参数用&amp;连接，<code>/user/?id=1&amp;name=test</code>，req.query.id –&gt; 1，req.query.name –&gt; test。</p><h3 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h3><p>通过post方式提交的参数<code>$.post(&#39;/add&#39;, {sid: &#39;sid&#39;})</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let bodyParser = require(&apos;body-parser&apos;)</span><br><span class="line">let multer = require(&apos;multer&apos;);</span><br><span class="line">let upload = require(&apos;multer&apos;); // for parsing multipart/form-data</span><br><span class="line">app.use(bodyParser.urlencode(&#123;extended: true&#125;)) // for parsing application/x-www-form-urlencoded</span><br><span class="line">app.use(bodyParser.json()) //  for parsing application/json</span><br><span class="line">app.post(&apos;/add&apos;, function(req, res)&#123;</span><br><span class="line">    let sid = req.body.sid;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&apos;/profile&apos;, upload.array(), function (req, res, next) &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">  res.json(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="req-param"><a href="#req-param" class="headerlink" title="req.param"></a>req.param</h3><p>req.param()是req.query、req.body、以及req.params获取参数的三种方式的封装，req.params(name)返回name参数的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// POST name=tobi</span><br><span class="line">app.post(&apos;/user?name=tobi&apos;,function(req,res)&#123;</span><br><span class="line"> req.param(&apos;name&apos;);</span><br><span class="line"> // =&gt; &quot;tobi&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ?name=tobi</span><br><span class="line">req.param(&apos;name&apos;)</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br><span class="line"></span><br><span class="line">// /user/tobi for /user/:name</span><br><span class="line">req.param(&apos;name&apos;)</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs接收get请求参数&quot;&gt;&lt;a href=&quot;#nodejs接收get请求参数&quot; class=&quot;headerlink&quot; title=&quot;nodejs接收get请求参数&quot;&gt;&lt;/a&gt;nodejs接收get请求参数&lt;/h2&gt;&lt;p&gt;在http协议中，一个完整的url路
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="nodejs" scheme="http://blog.juphy.com/tags/nodejs/"/>
    
      <category term="express" scheme="http://blog.juphy.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Angular组件通信</title>
    <link href="http://blog.juphy.com/2018/06/20/Angular%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.juphy.com/2018/06/20/Angular组件通信/</id>
    <published>2018-06-20T06:56:00.000Z</published>
    <updated>2018-08-09T06:41:20.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入属性（父组件-gt-子组件）"><a href="#输入属性（父组件-gt-子组件）" class="headerlink" title="输入属性（父组件-&gt;子组件）"></a>输入属性（父组件-&gt;子组件）</h2><blockquote><p>@Input，自定义属性</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输出属性（子组件-gt-父组件）"><a href="#输出属性（子组件-gt-父组件）" class="headerlink" title="输出属性（子组件-&gt;父组件）"></a>输出属性（子组件-&gt;父组件）</h2><blockquote><p>@Output()，自定义事件</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;p&gt;&#123;&#123;changeMsg&#125;&#125;&lt;/p&gt;</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;</span><br><span class="line">    (change)=&quot;countChange($event)&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line"></span><br><span class="line">  changeMsg: string;</span><br><span class="line"></span><br><span class="line">  countChange(event: number) &#123;</span><br><span class="line">    this.changeMsg = `子组件change事件已触发，当前值是: $&#123;event&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义事件change，接收发送过来的数据。</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input, Output, EventEmitter &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当值改变时，通过事件发射数据接收。</span><br></pre></td></tr></table></figure></p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><blockquote><p>[()]，Angular的双向绑定</p></blockquote><p><em>通过修改绑定属性的方式，使用双向绑定即可，此时在子组件中只需要接收数据。</em></p><h2 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h2><blockquote><p>通过子组件标签的#name,则name就相当于子组件component。</p></blockquote><p>parent.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;ChildComponent&#125; from &apos;./child-component.ts&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;parent-component&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;child-component #child&gt;&lt;/child-component&gt;</span><br><span class="line">    &lt;button (click)=&quot;child.name = childName&quot;&gt;设置子组件名称&lt;/button&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ParentComponent implements OnInit &#123;</span><br><span class="line"></span><br><span class="line">  private childName: string;</span><br><span class="line"></span><br><span class="line">  constructor() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    this.childName = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;child-component&apos;,</span><br><span class="line">  template: `I&apos;m &#123;&#123; name &#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="在查询参数中传递参数"><a href="#在查询参数中传递参数" class="headerlink" title="在查询参数中传递参数"></a>在查询参数中传递参数</h3><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/cinema-chain/cinema&apos;]&quot; [queryParams]=&quot;&#123;chain: 1&#125;&quot;&gt;查看影院&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>点击跳转时，/cinema-chain/cinema?chain=1（?chain=1就是从路由里面传递过来的参数）。</p><p>接收参数的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.queryParams[&apos;chain&apos;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="在url路由路径中传递参数"><a href="#在url路由路径中传递参数" class="headerlink" title="在url路由路径中传递参数"></a>在url路由路径中传递参数</h3><p>在path中传递参数就需要先修改原有的路径使其可以携带参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const routes: Routes = [</span><br><span class="line">  &#123;path: &apos;main/:type&apos;, loadChildren: &apos;./index/index.module#IndexModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;upload&apos;, loadChildren: &apos;./components/upload/upload.module#UploadModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;operation&apos;, loadChildren: &apos;./components/operation/operation.module#OperationModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;compare/:type&apos;, loadChildren: &apos;./components/compare/compare.module#CompareModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;**&apos;, component: PageNotFoundComponent&#125;,</span><br><span class="line">];</span><br><span class="line">整个路径被划分成两段变量</span><br></pre></td></tr></table></figure></p><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line">这里的routerLink是一个数组，第一个值为路由的跳转路径，第二值为路由携带参数的值，这里传递的值为2</span><br><span class="line"></span><br><span class="line">或者这样传递</span><br><span class="line"> constructor(private router: Router) &#123;</span><br><span class="line">    this.router.navigate([&apos;/product&apos;,1]);</span><br><span class="line">    this.router.navigateByUrl(&apos;/product/1&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">或者这样传递</span><br><span class="line">&lt;a routerLink=&quot;/home/&#123;&#123;变量名&#125;&#125;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>页面跳转的结果：/home/2</p><p>接收参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.params[&apos;id&apos;];</span><br><span class="line">   或者 chain = this.activatedRoute.snapshot.paramMap.get(&apos;id&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><em>不能同时使用参数查询方式和路由路径Url 方式传递同一个页面的参数，否则报错。</em></p><h3 id="参数快照和参数订阅"><a href="#参数快照和参数订阅" class="headerlink" title="参数快照和参数订阅"></a>参数快照和参数订阅</h3><p>参数快照：获取路由中传递的参数的值得一个方法就用到了参数快照snapshot。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">change_id()&#123;</span><br><span class="line">  this.router.navigate([&apos;/home&apos;,1]);</span><br><span class="line">&#125;</span><br><span class="line">路由路径中想home同时传递了两个参数，1和2</span><br></pre></td></tr></table></figure></p><p>当在页面第一次加载的时候会创建一次home，将2这个值传入页面，当点击按钮出发change_id事件的时候也会导航到home，但是在此之前主页已经被创建，并已经被赋值，此时导航到主页，主页并不会再次被创建，所以自然不会再次获取第二次导航过来的路由所携带的参数和值，但是路径变为了/home/1。</p><p>然而页面上的值仍然是2，获取当前路由所传递的参数值失败。这就是参数快照的弱点，为了解决这个问题引入了参数订阅：subscribe()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   this.activatedRoute.params.subscribe(params =&gt; &#123;</span><br><span class="line">       const id = params[&apos;id&apos;];</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>采用参数订阅的方式subscribe()获取到一个类型为Params的属性params，并返回params里面的Id复制给本地变量homeID，这样就不会出现路径在变，但是页面里面的参数值不变的情况；</p><h2 id="ViewChild-装饰器"><a href="#ViewChild-装饰器" class="headerlink" title="@ViewChild 装饰器"></a>@ViewChild 装饰器</h2><blockquote><p>父组件获取子组件数据需要借助@ViewChild(),子组件直接引用。</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, ViewChild, AfterViewInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ChildComponent &#125; from &apos;./child.component&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h4&gt;Welcome to Angular World&lt;/h4&gt;</span><br><span class="line">    &lt;exe-child&gt;&lt;/exe-child&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  title: number = 123;</span><br><span class="line">  @ViewChild(ChildComponent)</span><br><span class="line">  childCmp: ChildComponent;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    this.childCmp.name = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-child&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;Child Component&lt;/p&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">    name: string = &apos;&apos;;</span><br><span class="line">    constructor(private appcomponent:AppComponent) &#123;</span><br><span class="line">        this.appcomponent.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基于RxJS-Subject"><a href="#基于RxJS-Subject" class="headerlink" title="基于RxJS Subject"></a>基于RxJS Subject</h2><p><code>rxjs版本基于6需要结合rxjs-compat使用</code><br>message.service.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;of&#125; from &apos;rxjs/observable/of&apos;;</span><br><span class="line">import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class MessageService &#123;</span><br><span class="line">  private subject = new Subject&lt;any&gt;();</span><br><span class="line">  message: any;</span><br><span class="line"></span><br><span class="line">  sendMessage(message: any) &#123;</span><br><span class="line">    this.message = message;</span><br><span class="line">    this.subject.next(message);</span><br><span class="line">    this.subject.complete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearMessage() &#123;</span><br><span class="line">    this.message = null;</span><br><span class="line">    this.subject.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessage(): Observable&lt;any&gt; &#123;</span><br><span class="line">    // return this.subject.asObservable(); // 数据一直在维持，会产生变化</span><br><span class="line">    return of(this.message); // 数据值传递一次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>home.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-home&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Home&lt;/h1&gt;</span><br><span class="line">        &lt;button (click)=&quot;sendMessage()&quot;&gt;Send Message&lt;/button&gt;</span><br><span class="line">        &lt;button (click)=&quot;clearMessage()&quot;&gt;Clear Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HomeComponent &#123;</span><br><span class="line">    constructor(private messageService: MessageService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    sendMessage(): void &#123;</span><br><span class="line">        this.messageService.sendMessage(&apos;Message from Home Component to App Component!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearMessage(): void &#123;</span><br><span class="line">        this.messageService.clearMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnDestroy &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Subscription &#125; from &apos;rxjs/Subscription&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;my-app&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div *ngIf=&quot;message&quot;&gt;&#123;&#123;message.text&#125;&#125;&lt;/div&gt;</span><br><span class="line">       &lt;exe-home&gt;&lt;/exe-home&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppComponent implements OnDestroy &#123;</span><br><span class="line">    message: any;</span><br><span class="line">    subscription: Subscription;</span><br><span class="line"></span><br><span class="line">    constructor(private messageService: MessageService) &#123;</span><br><span class="line">        this.subscription = this.messageService.getMessage().subscribe( message =&gt; &#123;</span><br><span class="line">                                      this.message = message;</span><br><span class="line">                                 &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnDestroy() &#123;</span><br><span class="line">        this.subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>更多<a href="https://github.com/RxJS-CN" target="_blank" rel="noopener">RxJS知识以及用法</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入属性（父组件-gt-子组件）&quot;&gt;&lt;a href=&quot;#输入属性（父组件-gt-子组件）&quot; class=&quot;headerlink&quot; title=&quot;输入属性（父组件-&amp;gt;子组件）&quot;&gt;&lt;/a&gt;输入属性（父组件-&amp;gt;子组件）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由缓存</title>
    <link href="http://blog.juphy.com/2018/06/13/angular%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98/"/>
    <id>http://blog.juphy.com/2018/06/13/angular路由缓存/</id>
    <published>2018-06-13T06:56:00.000Z</published>
    <updated>2018-08-09T06:43:14.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular路由缓存"><a href="#angular路由缓存" class="headerlink" title="angular路由缓存"></a>angular路由缓存</h2><p>路由缓存，input输入状态， 下拉框选中状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#123;RouteReuseStrategy, DefaultUrlSerializer, ActivatedRouteSnapshot, DetachedRouteHandle&#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export class CustomReuseStrategy implements RouteReuseStrategy &#123;</span><br><span class="line"></span><br><span class="line">  public handlers: &#123; [key: string]: DetachedRouteHandle &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  表示对路由允许复用</span><br><span class="line">  shouldDetach(route: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    默认对所有路由复用 可通过给路由配置项增加data: &#123; keep: true &#125;来进行选择性使用，代码如下</span><br><span class="line">    如果是懒加载路由需要在生命组件的位置进行配置</span><br><span class="line">    if (!route.data.keep) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  当路由离开时会触发。按path作为key存储路由快照&amp;组件当前实例对象</span><br><span class="line">  store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void &#123;</span><br><span class="line">    this.handlers[route.routeConfig.path] = handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  若path在缓存中有的都认为允许还原路由</span><br><span class="line">  shouldAttach(route: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    return !!route.routeConfig &amp;&amp; !!this.handlers[route.routeConfig.path];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  从缓存中获取快照，若无则返回null</span><br><span class="line">  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123;</span><br><span class="line">    if (!route.routeConfig) return null;</span><br><span class="line">    if (route.routeConfig.loadChildren) return null; 在loadChildren路径上通过修改自定义RouteReuseStrategy中的检索函数时从不检索分离的路由。</span><br><span class="line">    return this.handlers[route.routeConfig.path];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  进入路由触发，判断是否同一路由</span><br><span class="line">  shouldReuseRoute(future: ActivatedRouteSnapshot, current: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    return future.routeConfig === current.routeConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码引入到app.module.ts文件的providers: [{ provide: RouteReuseStrategy, useClass: AppRoutingCache }]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular路由缓存&quot;&gt;&lt;a href=&quot;#angular路由缓存&quot; class=&quot;headerlink&quot; title=&quot;angular路由缓存&quot;&gt;&lt;/a&gt;angular路由缓存&lt;/h2&gt;&lt;p&gt;路由缓存，input输入状态， 下拉框选中状态&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular的hash模式</title>
    <link href="http://blog.juphy.com/2018/06/06/angular%E7%9A%84hash%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.juphy.com/2018/06/06/angular的hash模式/</id>
    <published>2018-06-06T06:56:00.000Z</published>
    <updated>2018-08-09T06:44:23.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular开启hash模式"><a href="#angular开启hash模式" class="headerlink" title="angular开启hash模式"></a>angular开启hash模式</h2><p>Hash 模式是基于锚点定位的内部链接机制，在 URL 加上 # ，然后在 # 后面加上 hash 标签，根据不同的标签做定位</p><ul><li>针对初始化时带有路由的项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路由时，routing.module.ts文件中，</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes , &#123; useHash: true &#125;)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>app.module.ts中进行配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入相关服务</span><br><span class="line">import &#123;HashLocationStrategy, LocationStrategy&#125; from &apos;@angular/common&apos;;</span><br><span class="line">// 在@NgModule中的配置如下 | 服务依赖注入</span><br><span class="line">providers: [&#123;provide: LocationStrategy, useClass: HashLocationStrategy&#125;]</span><br></pre></td></tr></table></figure><p><strong> URL 中包含的 hash 信息是不会提交到服务端，所以若要使用 SSR (Server-Side Rendered) ，就不能使用 Hash 模式即不能使用 HashLocationStrategy 策略。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular开启hash模式&quot;&gt;&lt;a href=&quot;#angular开启hash模式&quot; class=&quot;headerlink&quot; title=&quot;angular开启hash模式&quot;&gt;&lt;/a&gt;angular开启hash模式&lt;/h2&gt;&lt;p&gt;Hash 模式是基于锚点定位的内部链
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular如何使用第三方库</title>
    <link href="http://blog.juphy.com/2018/05/31/Angular%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>http://blog.juphy.com/2018/05/31/Angular如何使用第三方库/</id>
    <published>2018-05-31T06:56:00.000Z</published>
    <updated>2018-08-09T06:46:38.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript模块系统"><a href="#TypeScript模块系统" class="headerlink" title="TypeScript模块系统"></a>TypeScript模块系统</h2><p>模块是指在其自身作用域里执行，而不是在全局作用域里；模块间是依靠 export 和 import 建立关系。编译器在编译过程中，也是依赖这种关系来定位需要编译的文件。</p><p>TypeScript 依然还是以 JavaScript 文件的形式发布类库，这会导致类型无法表述，需要配合<code>声明文件</code>对其进行类型描述；因此<code>声明文件</code>成了类库一个必不可少的组成部分。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="有声明文件"><a href="#有声明文件" class="headerlink" title="有声明文件"></a>有声明文件</h3><p>要分清类库是否有声明文件 *.d.ts</p><blockquote><p>类库自带</p></blockquote><p>从 Npm 安装一个依赖包后，可以直接检查该依赖包库的 package.json 是否包含 typings 节点，该节点对应的文件就是声明文件。</p><blockquote><p>TypeSearch检索</p></blockquote><p>TypeScript 提供了一个叫 <a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeSearch</a> 网站，可以直接输入关键词检查是否包含该类库的声明文件。</p><h3 id="无声明文件"><a href="#无声明文件" class="headerlink" title="无声明文件"></a>无声明文件</h3><p>Angular Cli 创建的项目会包含一个 src/typings.d.ts 声明文件，它会自动包含在全局声明定义中，而把这些类库的声明信息写在这里面再好不过。</p><p>一般而言自己很难对一个类库写一个完整的声明文件，这对于成本来说太不合算，因此往往都是只对部分全局对象做一个 any （表示忽略该静态类型检查）亦可，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare const XLSX: any</span><br></pre></td></tr></table></figure></p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="有声明文件-1"><a href="#有声明文件-1" class="headerlink" title="有声明文件"></a>有声明文件</h3><p>对于有声明文件，无需额外做什么，只需在需要模块的地方使用 import 来导入即可。</p><h3 id="无声明文件-1"><a href="#无声明文件-1" class="headerlink" title="无声明文件"></a>无声明文件</h3><p>使用 any 来表示忽略静态类型检查，意味者无法享受声明文件带来的智能提示快感，可以在项目的任意位置直接使用它，但也仅仅只能识别声明的变量，而实例的方法或属性是不可知的。</p><p>除此之外 TypeScript 编译过程中也不会对 G2 做任何类型检查，G2 是否真的存在只能由自己把握。对于 Angular 而言，是需要额外在 angular.json 的 scripts 节点上明确加载这些模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TypeScript模块系统&quot;&gt;&lt;a href=&quot;#TypeScript模块系统&quot; class=&quot;headerlink&quot; title=&quot;TypeScript模块系统&quot;&gt;&lt;/a&gt;TypeScript模块系统&lt;/h2&gt;&lt;p&gt;模块是指在其自身作用域里执行，而不是在全局作
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
      <category term="TypeScript" scheme="http://blog.juphy.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由</title>
    <link href="http://blog.juphy.com/2018/05/24/angular%E8%B7%AF%E7%94%B1/"/>
    <id>http://blog.juphy.com/2018/05/24/angular路由/</id>
    <published>2018-05-24T06:56:00.000Z</published>
    <updated>2018-08-09T06:50:12.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular路由"><a href="#angular路由" class="headerlink" title="angular路由"></a>angular路由</h2><blockquote><p>Base href</p></blockquote><p>index.html中存在<code>&lt;</code>base<code>&gt;</code>标签,路由需要根据这个来确定应用程序的根目录。例如，当我们转到<code>http://example.com/page1</code>时，如果我们没有定义应用程序的基础路径，路由将无法知道我们的应用的托管地址是<code>http://example.com</code>还是<code>http://example.com/page1</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=&quot;/&quot;&gt;</span><br><span class="line">    &lt;title&gt;Application&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;app-root&gt;&lt;/app-root&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>Using the router</p></blockquote><p>要使用路由，我们需要在 AppModule 模块中，导入 RouterModule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class="line">import &#123; RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; AppComponent &#125; from &apos;./app.component&apos;;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule</span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>RouterModule.forRoot()</p></blockquote><p>RouterModule.forRoot() 方法用于在主模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = []; // 便于我们在需要的时候导出ROUTES到其他模块中</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>RouterModule.forChild()</p></blockquote><p>RouterModule.forChild() 与 Router.forRoot() 方法类似，但它只能应用在特性模块中。</p><p><em>根模块中使用 forRoot()，子模块中使用 forChild()。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CommonModule &#125; from &apos;@angular/common&apos;;</span><br><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    RouterModule.forChild(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Dynamic routes</p></blockquote><p>如果路由始终是静态的，那没有多大的用处。使用动态路由我们可以根据不同的路由参数，渲染不同的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HomeComponent &#125; from &apos;./home/home.component&apos;;</span><br><span class="line">import &#123; ProfileComponent &#125; from &apos;./profile/profile.component&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123; path: &apos;&apos;, component: HomeComponent &#125;,</span><br><span class="line">  &#123; path: &apos;/profile/:username&apos;, component: ProfileComponent &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>/routeUrl/:params</p><p>:params是路由参数，而不是URL的实际部分。</p><p>在访问路由的时候routerLink或者navigate的时候就可以直接传递参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ActivatedRoute &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;profile-page&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;profile&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; username &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsComponent implements OnInit &#123;</span><br><span class="line">  username: string;</span><br><span class="line">  constructor(private route: ActivatedRoute) &#123;&#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    this.route.params.subscribe((params) =&gt; this.username = params.username);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Child routes</p></blockquote><p>每个路由都支持子路由，在setttings路由中定义了两个子路由，它们将继承父路由的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SettingsComponent &#125; from &apos;./settings/settings.component&apos;;</span><br><span class="line">import &#123; ProfileSettingsComponent &#125; from &apos;./settings/profile/profile.component&apos;;</span><br><span class="line">import &#123; PasswordSettingsComponent &#125; from &apos;./settings/password/password.component&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;settings&apos;,</span><br><span class="line">    component: SettingsComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; path: &apos;profile&apos;, component: ProfileSettingsComponent &#125;,</span><br><span class="line">      &#123; path: &apos;password&apos;, component: PasswordSettingsComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>SettingsComponent组件中需要添加router-outlet指令，因为我们要在设置页面中呈现子路由。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;settings-page&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;settings&quot;&gt;</span><br><span class="line">      &lt;settings-header&gt;&lt;/settings-header&gt;</span><br><span class="line">      &lt;settings-sidebar&gt;&lt;/settings-sidebar&gt;</span><br><span class="line">      &lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsComponent &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>loadChildren</p></blockquote><p>SettingsModule 模块，用来保存所有 setttings 相关的路由信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CommonModule &#125; from &apos;@angular/common&apos;;</span><br><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;&apos;,</span><br><span class="line">    component: SettingsComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; path: &apos;profile&apos;, component: ProfileSettingsComponent &#125;,</span><br><span class="line">      &#123; path: &apos;password&apos;, component: PasswordSettingsComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    RouterModule.forChild(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在 SettingsModule 模块中我们使用 forChild() 方法，因为 SettingsModule 不是我们应用的主模块。</p><p>另一个主要的区别是我们将 SettingsModule 模块的主路径设置为空路径 (‘’)。因为如果我们路径设置为 /settings ，它将匹配 /settings/settings ，很明显这不是我们想要的结果。通过指定一个空的路径，它就会匹配 /settings 路径，这就是我们想要的结果。</p><p>AppModule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;settings&apos;,</span><br><span class="line">    loadChildren: &apos;./settings/settings.module#SettingsModule&apos;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>通过 loadChildren 属性，告诉 Angular 路由依据 loadChildren 属性配置的路径去加载 SettingsModule 模块。这就是模块懒加载功能的具体应用，当用户访问 /settings/** 路径的时候，才会加载对应的 SettingsModule 模块，这减少了应用启动时加载资源的大小。</p><ul><li>loadChildren 的属性值，该字符串由三部分组成：<ul><li>需要导入模块的相对路径</li><li><h1 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h1></li><li>导出模块类的名称</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular路由&quot;&gt;&lt;a href=&quot;#angular路由&quot; class=&quot;headerlink&quot; title=&quot;angular路由&quot;&gt;&lt;/a&gt;angular路由&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Base href&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由之history&amp;locationStrategy</title>
    <link href="http://blog.juphy.com/2018/05/17/angular%E8%B7%AF%E7%94%B1%E4%B9%8Bhistory&amp;locationStrategy/"/>
    <id>http://blog.juphy.com/2018/05/17/angular路由之history&amp;locationStrategy/</id>
    <published>2018-05-17T06:56:00.000Z</published>
    <updated>2018-08-09T06:51:22.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>length<br>  只读的，其值为一个整数，标志包括当前页面在内的会话历史中的记录数量，比如我们通常打开一个空白窗口，length 为 0，再访问一个页面，其 length 变为 1。</li><li>scrollRestoration<br>  允许 Web 应用在会话历史导航时显式地设置默认滚动复原，其值为 auto 或 manual。</li><li>state<br>  只读，返回代表会话历史堆栈顶部记录的任意可序列化类型数据值，我们可以以此来区别不同会话历史纪录<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3></li><li>back()<br>  返回会话历史记录中的上一个页面，等价于 window.history.go(-1) 和点击浏览器的后退按钮。</li><li>forward()<br>  进入会话历史记录中的下一个页面，等价于 window.history.go(1) 和点击浏览器的前进按钮。</li><li>go()<br>  加载会话历史记录中的某一个页面，通过该页面与当前页面在会话历史中的相对位置定位，如，-1 代表当前页面的上一个记录，1 代表当前页面的下一个页面。若不传参数或传入0，则会重新加载当前页面；若参数超出当前会话历史纪录数，则不进行操作。</li><li><p>pushState()<br>  在会话历史堆栈顶部插入一条记录，该方法接收三个参数，一个state 对象，一个页面标题，一个 URL：</p><ul><li><p>状态对象</p><p>  1、存储新添会话历史记录的状态信息对象，每次访问该条会话时，都会触发 popstate 事件，并且事件回调函数会接收一个参数，值为该事件对象的复制副本。</p><p>  2、状态对象可以是任何可序列化的数据，浏览器将状态对象存储在用户的磁盘以便用户再次重启浏览器时能恢复数据</p><p>  3、一个状态对象序列化后的最大长度是 640K，如果传递数据过大，则会抛出异常</p></li><li><p>页面标题</p><p>  目前该参数值会被忽略，暂不被使用，可以传入空字符串</p></li><li><p>页面 URL</p><p>  1、此参数声明新添会话记录的入口 URL</p><p>  2、在调用 pushState() 方法后，浏览器不会加载 URL 指向的页面，我们可以在 popstate 事件回调中处理页面是否加载</p><p>  3、此 URL 必须与当前页面 URL 同源,，否则会抛异常；其值可以是绝对地址，也可以是相对地址，相对地址会被基于当前页面 URL 解析得到绝对地址；若其值为空，则默认是当前页面 URL</p></li></ul></li><li><p>replaceState()</p><ul><li>更新会话历史堆栈顶部记录信息，支持的参数信息与 pushState() 一致。</li><li>pushState() 与 replaceState() 的区别：pushState()是在 history 栈中添加一个新的条目，replaceState() 是替换当前的记录值。此外这两个方法改变的只是浏览器关于当前页面的标题和 URL 的记录情况，并不会刷新或改变页面展示。</li></ul></li><li><p>onpopstate 事件</p><ul><li>window.onpopstate 是 popstate 事件在 window 对象上的事件句柄。每当处于激活状态的历史记录条目发生变化时，popstate 事件就会在对应 window 对象上触发。如果当前处于激活状态的历史记录条目是由 history.pushState() 方法创建，或者由 history.replaceState() 方法修改过的，则 popstate 事件对象的 state 属性包含了这个历史记录条目的 state 对象的一个拷贝。</li><li>调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。popstate 事件只会在浏览器某些行为下触发，比如点击后退、前进按钮 (或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法)。</li><li>当网页加载时，各浏览器对 popstate 事件是否触发有不同的表现，Chrome 和 Safari 会触发 popstate 事件，而 Firefox 不会。</li></ul></li></ul><h2 id="Hash模式和Html5模式"><a href="#Hash模式和Html5模式" class="headerlink" title="Hash模式和Html5模式"></a>Hash模式和Html5模式</h2><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p>Hash 模式是基于锚点定位的内部链接机制，在 URL 加上 # ，然后在 # 后面加上 hash 标签，根据不同的标签做定位</p><blockquote><p>针对初始化时带有路由的项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路由时，routing.module.ts文件中，</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes , &#123; useHash: true &#125;)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>app.module.ts中进行配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入相关服务</span><br><span class="line">import &#123;HashLocationStrategy, LocationStrategy&#125; from &apos;@angular/common&apos;;</span><br><span class="line">// 在@NgModule中的配置如下 | 服务依赖注入</span><br><span class="line">providers: [&#123;provide: LocationStrategy, useClass: HashLocationStrategy&#125;]</span><br></pre></td></tr></table></figure><p><code>URL 中包含的 hash 信息是不会提交到服务端，所以若要使用 SSR (Server-Side Rendered) ，就不能使用 Hash 模式即不能使用 HashLocationStrategy 策略。</code></p><h3 id="HTML5模式"><a href="#HTML5模式" class="headerlink" title="HTML5模式"></a>HTML5模式</h3><p>HTML 5 模式则直接使用跟”真实”的 URL 一样，如上面的路径，在 HTML 5 模式地址如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/u/angular4/user</span><br></pre></td></tr></table></figure></p><ul><li>HTML5模式下URL有两种访问方式:<ul><li>在浏览器地址栏直接输入 URL，这会向服务器请求加载页面。</li><li>在 Angular 应用程序中，访问 HTML 5 模式下的 URL 地址，这不需要重新加载页面，可以直接切换到对应的视图。</li></ul></li></ul><p>在 HTML 5 模式下，Angular 使用了 HTML 5 的 pushState() API 来动态改变浏览器的 URL 而不用重新刷新页面。</p><blockquote><p>开启HTML5模式</p></blockquote><p>导入 APP_BASE_HREF、LocationStrategy、PathLocationStrategy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; APP_BASE_HREF, LocationStrategy, PathLocationStrategy &#125; from &apos;@angular/common&apos;</span><br></pre></td></tr></table></figure><p>配置NgModule-providers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(routes)</span><br><span class="line">  ],</span><br><span class="line">  ..,</span><br><span class="line">  providers: [</span><br><span class="line">    &#123; provide: LocationStrategy, useClass: PathLocationStrategy &#125;,</span><br><span class="line">    &#123; provide: APP_BASE_HREF, useValue: &apos;/&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例代码中的 APP_BASE_HREF，用于设置资源 (图片、脚本、样式) 加载的基础路径。除了在 NgModule 中配置 provider 外，我们也可以在入口文件，如 index.html 文件 &lt;base&gt; 标签中设置基础路径。</p><p>&lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的路径来补全相对 URL 中缺失的部分。使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt; 标签中的 URL。具体使用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=&quot;/&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="LocationStrategy"><a href="#LocationStrategy" class="headerlink" title="LocationStrategy"></a>LocationStrategy</h2><p>LocationStrategy 用于从浏览器 URL 中读取路由状态。Angular 中提供两种 LocationStrategy 策略：</p><ul><li><p>HashLocationStrategy</p></li><li><p>PathLocationStrategy</p></li></ul><p>以上两种策略都是继承于 LocationStrategy 抽象类，该类的具体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export abstract class LocationStrategy &#123;</span><br><span class="line">  // 获取path路径</span><br><span class="line">  abstract path(includeHash?: boolean): string;</span><br><span class="line">  // 生成完整的外部链接</span><br><span class="line">  abstract prepareExternalUrl(internal: string): string;</span><br><span class="line">  // 添加会话历史状态</span><br><span class="line">  abstract pushState(state: any, title: string, url: string,</span><br><span class="line">      queryParams: string): void;</span><br><span class="line">  // 修改会话历史状态</span><br><span class="line">  abstract replaceState(state: any, title: string, url: string,</span><br><span class="line">      queryParams: string): void;</span><br><span class="line">  // 进入会话历史记录中的下一个页面</span><br><span class="line">  abstract forward(): void;</span><br><span class="line">  // 返回会话历史记录中的上一个页面</span><br><span class="line">  abstract back(): void;</span><br><span class="line">  // 设置popstate监听</span><br><span class="line">  abstract onPopState(fn: LocationChangeListener): void;</span><br><span class="line">  // 获取base地址信息</span><br><span class="line">  abstract getBaseHref(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashLocationStrategy"><a href="#HashLocationStrategy" class="headerlink" title="HashLocationStrategy"></a>HashLocationStrategy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashLocationStrategy 类继承于 LocationStrategy 抽象类，它的构造函数如下：</span><br><span class="line"></span><br><span class="line">export class HashLocationStrategy extends LocationStrategy &#123;</span><br><span class="line">  constructor(</span><br><span class="line">      private _platformLocation: PlatformLocation,</span><br><span class="line">      @Optional() @Inject(APP_BASE_HREF) _baseHref?: string) &#123;</span><br><span class="line">      super();</span><br><span class="line">      if (_baseHref != null) &#123;</span><br><span class="line">        this._baseHref = _baseHref;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数依赖 PlatformLocation 及 APP_BASE_HREF 关联的对象。APP_BASE_HREF 的作用，我们上面已经介绍过了，接下来我们来分析一下 PlatformLocation 对象。</p><h3 id="PlatformLocation"><a href="#PlatformLocation" class="headerlink" title="PlatformLocation"></a>PlatformLocation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// angular2/packages/platform-browser/src/browser.ts</span><br><span class="line">export const INTERNAL_BROWSER_PLATFORM_PROVIDERS: Provider[] = [</span><br><span class="line">  ...,</span><br><span class="line">  &#123;provide: PlatformLocation, useClass: BrowserPlatformLocation&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以知道在浏览器环境中，HashLocationStrategy 构造函数中注入的 PlatformLocation 对象是 BrowserPlatformLocation 类的实例。我们也先来看一下 BrowserPlatformLocation 类的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// angular2/packages/platform-browser/src/browser/location/browser_platform_location.ts</span><br><span class="line">export class BrowserPlatformLocation extends PlatformLocation &#123;</span><br><span class="line">  private _location: Location;</span><br><span class="line">  private _history: History;</span><br><span class="line"></span><br><span class="line">  constructor(@Inject(DOCUMENT) private _doc: any) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this._init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _init() &#123;</span><br><span class="line">    this._location = getDOM().getLocation(); // 获取浏览器平台下Location对象</span><br><span class="line">    this._history = getDOM().getHistory(); // 获取浏览器平台下的History对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 BrowserPlatformLocation 构造函数中，我们调用 _init() 方法，在方法体中，我们调用 getDOM() 方法返回对象中的 getLocation() 和 getHistory() 方法，分别获取 Location 对象和 History 对象。那 getDOM() 方法返回的是什么对象呢？其实该方法返回的是 DomAdapter 对象。</p><h3 id="DomAdapter"><a href="#DomAdapter" class="headerlink" title="DomAdapter"></a>DomAdapter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let _DOM: DomAdapter = null !;</span><br><span class="line"></span><br><span class="line">export function getDOM() &#123;</span><br><span class="line">  return _DOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setDOM(adapter: DomAdapter) &#123;</span><br><span class="line">  _DOM = adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setRootDomAdapter(adapter: DomAdapter) &#123;</span><br><span class="line">  if (!_DOM) &#123;</span><br><span class="line">    _DOM = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那什么时候会调用 setDOM() 或 setRootDomAdapter() 方法呢？通过查看 Angular 源码，我们发现在浏览器平台初始化时，会调用 setRootDomAdapter() 方法。具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export const INTERNAL_BROWSER_PLATFORM_PROVIDERS: Provider[] = [</span><br><span class="line">  &#123;provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true&#125;,</span><br><span class="line">  ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;History-对象&quot;&gt;&lt;a href=&quot;#History-对象&quot; class=&quot;headerlink&quot; title=&quot;History 对象&quot;&gt;&lt;/a&gt;History 对象&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://blog.juphy.com/2018/05/10/websocket/"/>
    <id>http://blog.juphy.com/2018/05/10/websocket/</id>
    <published>2018-05-10T06:56:00.000Z</published>
    <updated>2018-08-09T06:55:05.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li>特点：<ul><li>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（full-duplex）的通信。</li><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。</li><li>协议标识符是ws（如果加密，则为wss，对应 HTTPS 协议），服务器网址就是 URL。</li></ul></li></ul><h3 id="WebSocket握手"><a href="#WebSocket握手" class="headerlink" title="WebSocket握手"></a>WebSocket握手</h3><ul><li>浏览器发出：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: null</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>HTTP1.1 协议规定，Upgrade表示将通信协议从HTTP/1.1转向该字段指定的协议。Connection字段表示浏览器通知服务器，如果可以的话，就升级到 WebSocket 协议。Origin字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）。Sec-WebSocket-Key则是用于握手协议的密钥，是 Base64 编码的16字节随机字符串。</p><ul><li>服务器响应：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Origin: null</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><p>服务器同样用Connection字段通知浏览器，需要改变协议。Sec-WebSocket-Accept字段是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取 SHA-1 的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 WebSocket 请求。Sec-WebSocket-Location字段表示进行通信的 WebSocket 网址。</p><blockquote><p>完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据。</p></blockquote><h3 id="客服端API"><a href="#客服端API" class="headerlink" title="客服端API"></a>客服端API</h3><ul><li>浏览器对 WebSocket 协议的处理，无非就是三件事。<ul><li>建立连接和断开连接</li><li>发送数据和接收数据</li><li>处理错误</li></ul></li></ul><h4 id="1、-构造WebSocket函数"><a href="#1、-构造WebSocket函数" class="headerlink" title="1、 构造WebSocket函数"></a>1、 构造WebSocket函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&apos;ws://localhost: 8080&apos;);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><h4 id="2、webSocket-readyState"><a href="#2、webSocket-readyState" class="headerlink" title="2、webSocket.readyState"></a>2、webSocket.readyState</h4><ul><li>readyState属性返回实例对象的当前状态，共有四种。<ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">switch (ws.readyState) &#123;</span><br><span class="line">  case WebSocket.CONNECTING:</span><br><span class="line">  // case 0:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.OPEN:</span><br><span class="line">  // case 1:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSING:</span><br><span class="line">  // case 2:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSED:</span><br><span class="line">  // case 3:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    // this never happens</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、webSocket的api"><a href="#3、webSocket的api" class="headerlink" title="3、webSocket的api"></a>3、webSocket的api</h4><ul><li>webSocket.onopen 用于指定连接成功后的回调函数</li><li>webSocket.onclose 用于指定连接关闭后的回调函数</li><li>webSocket.onmessage 用于指定收到服务器数据后的回调函数，服务器数据可能是文本，也可能是二进制数据（blob对象或ArrayBuffer）</li><li>webSocket.send() 用于向服务器发送数据</li><li>webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</li><li>webSocket.onerror</li></ul><h2 id="RxJS封装的WebSocket"><a href="#RxJS封装的WebSocket" class="headerlink" title="RxJS封装的WebSocket"></a>RxJS封装的WebSocket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class WebsocketService &#123;</span><br><span class="line">  private ws: WebSocket;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> // 发送数据</span><br><span class="line">  send(message: any) &#123;</span><br><span class="line">    this.ws.send(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> // 建立连接</span><br><span class="line">  connect(url: string): Observable&lt;any&gt; &#123;</span><br><span class="line">    this.ws = new WebSocket(url);</span><br><span class="line">    return new Observable(observer =&gt; &#123;</span><br><span class="line">      this.ws.onmessage = (event) =&gt; observer.next(event.data);</span><br><span class="line">      this.ws.onerror = (event) =&gt; observer.error(event);</span><br><span class="line">      this.ws.onclose = (event) =&gt; &#123;</span><br><span class="line">        console.log(event, &apos;服务器端断开链接！&apos;);</span><br><span class="line">        observer.complete();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> // 断开连接</span><br><span class="line">  disconnect() &#123;</span><br><span class="line">    this.ws.close();</span><br><span class="line">    console.log(&apos;浏览器端断开链接！&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;服务器可以主动向客户端推送信息，客户端也可以主动
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
      <category term="WebSocket" scheme="http://blog.juphy.com/tags/WebSocket/"/>
    
  </entry>
  
</feed>
