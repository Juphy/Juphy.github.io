<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挽留之王小石</title>
  <icon>https://www.gravatar.com/avatar/a23107e3958da4844989715e80058f71</icon>
  <subtitle>Hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.juphy.cn/"/>
  <updated>2018-09-06T03:04:07.752Z</updated>
  <id>http://blog.juphy.cn/</id>
  
  <author>
    <name>Juphy</name>
    <email>gaojuphy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular中的http请求</title>
    <link href="http://blog.juphy.cn/blogs/5f94f955.html"/>
    <id>http://blog.juphy.cn/blogs/5f94f955.html</id>
    <published>2018-09-05T06:56:00.000Z</published>
    <updated>2018-09-06T03:04:07.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote><p>设置查询参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.juphy.cn/todos?_page=1&amp;_limit=10</span><br></pre></td></tr></table></figure><blockquote><p>创建HttpParams对象</p></blockquote><ol><li>直接链式创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HttpClient, HttpParams &#125; from &apos;@angular/common/http&apos;;</span><br><span class="line"></span><br><span class="line">const params = new HttpParams().set(&apos;_page&apos;, 1).set(&apos;_limit&apos;, 10);</span><br><span class="line"></span><br><span class="line">this.http.get(&apos;https://www.juphy.cn/todos&apos;, &#123;params&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>通过链式语法调用 set() 方法，构建 HttpParams 对象。这是因为HttpParams对象是不可变的，通过set() 方法可以防止该对象被修改。每当调用 set() 方法，将会返回包含新值的 HttpParams 对象。</p><ol start="2"><li>使用formString</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const params = new HttpParams(&#123;formString: &apos;_page=1&amp;_limit=10&apos;&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用formObject</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const params = new HttpParams(&#123; fromObject: &#123; _page: &quot;1&quot;, _limit: &quot;10&quot; &#125; &#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>使用request API</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.http.request(&apos;GET&apos;, &apos;https://www.juphy.cn/todos&apos;, &#123;params&#125;);</span><br></pre></td></tr></table></figure><h2 id="获取完整响应"><a href="#获取完整响应" class="headerlink" title="获取完整响应"></a>获取完整响应</h2><p>默认情况下，httpClient服务返回的是响应体，如果需要获取响应头的相关信息，可以设置options的对象的observe属性值为response来获取完整的响应对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.http.get(&apos;https://www.juphy.cn/todos&apos;,&#123;</span><br><span class="line">    observe: &apos;response&apos;</span><br><span class="line">&#125;).subscribe(res =&gt; &#123;</span><br><span class="line">    console.dir(&apos;Response:&apos;+res.status);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="设置响应类型"><a href="#设置响应类型" class="headerlink" title="设置响应类型"></a>设置响应类型</h2><p>options设置responseType属性的值，’text’,’arraybuffer’,’blob’。</p><h2 id="设置Http-Headers"><a href="#设置Http-Headers" class="headerlink" title="设置Http Headers"></a>设置Http Headers</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const params = new HttpParams(&#123; fromObject: &#123; _page: &quot;1&quot;, _limit: &quot;10&quot; &#125; &#125;);</span><br><span class="line">const headers = new HttpHeaders().set(&apos;Content-Type&apos;, &apos;application/json; charset=UTF-8&apos;);</span><br><span class="line">this.http.get(&apos;url&apos;, &#123;headers, params&#125;);</span><br></pre></td></tr></table></figure><h2 id="多个http请求"><a href="#多个http请求" class="headerlink" title="多个http请求"></a>多个http请求</h2><h3 id="并行发送"><a href="#并行发送" class="headerlink" title="并行发送"></a>并行发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const parallel$ = forkJoin(</span><br><span class="line">    this.http.get(&apos;url1&apos;),</span><br><span class="line">    this.http.get(&apos;url2&apos;)</span><br><span class="line">);</span><br><span class="line">parallel$.subscribe(res =&gt;&#123;</span><br><span class="line">    res是一个数组包含多个请求返回的结果。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="顺序发送"><a href="#顺序发送" class="headerlink" title="顺序发送"></a>顺序发送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const sequence$ = this.http.get(&apos;url1&apos;)</span><br><span class="line">    .pipe(</span><br><span class="line">        switchMap(res =&gt;&#123;</span><br><span class="line">            // 此res是url1返回的结果</span><br><span class="line">            return this.http.get(&apos;url2&apos;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">    sequence$.subscribe(res=&gt;&#123;</span><br><span class="line">        res// 此res是url2返回的结果</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="控制返回结果"><a href="#控制返回结果" class="headerlink" title="控制返回结果"></a>控制返回结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const sequence$ = this.http.get(&apos;url1&apos;)</span><br><span class="line">    .pipe(</span><br><span class="line">        switchMap(res =&gt;&#123;</span><br><span class="line">            // 此res是url1返回的结果</span><br><span class="line">            return this.http.get(&apos;url2&apos;);</span><br><span class="line">        &#125;, (res1, res2) =&gt; [res1, res2]) // 此处控制返回结果</span><br><span class="line">    );</span><br><span class="line">    sequence$.subscribe(res=&gt;&#123;</span><br><span class="line">        res; // [res1, res2]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="请求异常处理"><a href="#请求异常处理" class="headerlink" title="请求异常处理"></a>请求异常处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; of &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &#123; catchError &#125; from &quot;rxjs/operators&quot;;</span><br><span class="line"></span><br><span class="line">this.http.get(&apos;url&apos;).pipe(</span><br><span class="line">    catchError(error =&gt; &#123;</span><br><span class="line">        console.error(&apos;Error catched&apos;, error);</span><br><span class="line">        return of(&#123;description: &apos;Error Value Emitted&apos;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">).subscribe(res =&gt; console.log(res));</span><br></pre></td></tr></table></figure><h2 id="Http拦截器"><a href="#Http拦截器" class="headerlink" title="Http拦截器"></a>Http拦截器</h2><h3 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h3><p>拦截器提供了一种用于拦截、修改请求和响应的机制，类似于express中间件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable &#125; from &quot;@angular/core&quot;;</span><br><span class="line">import &#123; HttpEvent, HttpRequest, HttpHandler, HttpInterceptor &#125; from &quot;@angular/common/http&quot;;</span><br><span class="line">import &#123; Observable, of, throwError &#125; from &apos;rxjs&apos;;</span><br><span class="line">import &#123; mergeMap, catchError &#125; from &apos;rxjs/operators&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">// 定义一个类并实现HttpInterceptor接口</span><br><span class="line">export class DefaultInterceptor implements HttpInterceptor &#123;</span><br><span class="line">  constructor(private injector: Injector)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  private handleData(</span><br><span class="line">    event: HttpResponse&lt;any&gt; | HttpErrorResponse</span><br><span class="line">  ): Observable&lt;any&gt;&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">    switch(event.status)&#123;</span><br><span class="line">        case 200:</span><br><span class="line">        break;</span><br><span class="line">        case 401:</span><br><span class="line">        break;</span><br><span class="line">        case 403:</span><br><span class="line">        break;</span><br><span class="line">        case 404:</span><br><span class="line">        break;</span><br><span class="line">        case 500:</span><br><span class="line">        break;</span><br><span class="line">        default:</span><br><span class="line">            if(event instanceof HttpErrorResponse)&#123;</span><br><span class="line">                console.warn(</span><br><span class="line">                    &apos;未可知错误，大部分是由于后端不支持CORS或无效配置引起&apos;,</span><br><span class="line">                    event</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return of(event);</span><br><span class="line">  &#125;</span><br><span class="line">  intercept(</span><br><span class="line">    req: HttpRequest&lt;any&gt;, // HttpRequest，即请求对象</span><br><span class="line">    next: HttpHandler // HttpHandler，该对象有一个handle()方法，该方法返回一个Observable对象。</span><br><span class="line">  ): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123;</span><br><span class="line">     let url= req.url; // 设置url形式，统一加上服务端前缀</span><br><span class="line">     const newReq = req.clone(</span><br><span class="line">        url: url,</span><br><span class="line">        headers: req.headers.set(&quot;X-CustomAuthHeader&quot;, &quot;iloveangular&quot;)</span><br><span class="line">     );</span><br><span class="line">     return next.handle(newReq).pipe(</span><br><span class="line">        mergeMap((event: any) =&gt; &#123;</span><br><span class="line">            // 允许统一对请求错误进行处理，这是因为一个请求若是业务上错误的情况下其HTTP请求的状态是200的情况下需要</span><br><span class="line">            if(event instanceof HttpReponse &amp;&amp; event.status === 200) return this.handleData(event);</span><br><span class="line">            // 若一切正常，则后续操作</span><br><span class="line">            return of(event);</span><br><span class="line">        &#125;),</span><br><span class="line">        catchError((err: HttpErrorResponse) =&gt; this.handleData(err))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CachingInterceptor"><a href="#CachingInterceptor" class="headerlink" title="CachingInterceptor"></a>CachingInterceptor</h3><p>拦截器实现简单的缓存控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义一个Cache接口：</span><br><span class="line">import &#123; HttpRequest, HttpResponse &#125; from &apos;@angular/common/http&apos;;</span><br><span class="line"></span><br><span class="line">export interface Cache &#123;</span><br><span class="line">  get(req: HttpRequest&lt;any&gt;): HttpResponse&lt;any&gt; | null;</span><br><span class="line">  put(req: HttpRequest&lt;any&gt;, res: HttpResponse&lt;any&gt;): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>get(req: HttpRequest): HttpResponse | null —— 用于获取 req 请求对象对应的响应对象；</li><li>put(req: HttpRequest, res: HttpResponse): void; —— 用于保存 req 对象对应的响应对象。</li></ul><p>在实际的场景中，一般会设置一个最大的缓存时间，即缓存的有效期，在有效期内，如果缓存存在，则会直接返回已缓存的响应对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HttpResponse &#125; from &quot;@angular/common/http&quot;;</span><br><span class="line"></span><br><span class="line">export const MAX_CACHE_AGE = 30000; // 单位为毫秒</span><br><span class="line"></span><br><span class="line">export interface CacheEntry &#123;</span><br><span class="line">  url: string;</span><br><span class="line">  response: HttpResponse&lt;any&gt;;</span><br><span class="line">  entryTime: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>url: string —— 被缓存的请求 URL 地址</li><li>response: HttpResponse —— 被缓存的响应对象</li><li>entryTime: number —— 响应对象被缓存的时间，用于判断缓存是否过期</li></ul><p>实现CacheService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable &#125; from &quot;@angular/core&quot;;</span><br><span class="line">import &#123; HttpRequest, HttpResponse &#125; from &quot;@angular/common/http&quot;;</span><br><span class="line">import &#123; Cache &#125; from &quot;./cache&quot;;</span><br><span class="line">import &#123; CacheEntry, MAX_CACHE_AGE &#125; from &quot;./cache.entry&quot;;</span><br><span class="line"></span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: &quot;root&quot;</span><br><span class="line">&#125;)</span><br><span class="line">export class CacheService implements Cache &#123;</span><br><span class="line">  cacheMap = new Map&lt;string, CacheEntry&gt;();</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  get(req: HttpRequest&lt;any&gt;): HttpResponse&lt;any&gt; | null &#123;</span><br><span class="line">    // 判断当前请求是否已被缓存，若未缓存则返回null</span><br><span class="line">    const entry = this.cacheMap.get(req.urlWithParams);</span><br><span class="line">    if (!entry) return null;</span><br><span class="line">    // 若缓存存在，则判断缓存是否过期，若已过期则返回null。否则返回请求对应的响应对象</span><br><span class="line">    const isExpired = Date.now() - entry.entryTime &gt; MAX_CACHE_AGE;</span><br><span class="line">    console.log(`req.urlWithParams is Expired: $&#123;isExpired&#125; `);</span><br><span class="line">    return isExpired ? null : entry.response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  put(req: HttpRequest&lt;any&gt;, res: HttpResponse&lt;any&gt;): void &#123;</span><br><span class="line">    // 创建CacheEntry对象</span><br><span class="line">    const entry: CacheEntry = &#123;</span><br><span class="line">      url: req.urlWithParams,</span><br><span class="line">      response: res,</span><br><span class="line">      entryTime: Date.now()</span><br><span class="line">    &#125;;</span><br><span class="line">    this.logger.log(`Save entry.url response into cache`);</span><br><span class="line">    // 以请求url作为键，CacheEntry对象为值，保存到cacheMap中。并执行</span><br><span class="line">    // 清理操作，即清理已过期的缓存。</span><br><span class="line">    this.cacheMap.set(req.urlWithParams, entry);</span><br><span class="line">    this.deleteExpiredCache();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private deleteExpiredCache() &#123;</span><br><span class="line">    this.cacheMap.forEach(entry =&gt; &#123;</span><br><span class="line">      if (Date.now() - entry.entryTime &gt; MAX_CACHE_AGE) &#123;</span><br><span class="line">        this.cacheMap.delete(entry.url);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现CachingInterceptor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CacheService &#125; from &apos;../cache.service&apos;;</span><br><span class="line">const CACHABLE_URL = &apos;url&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class CachingInterceptor implements HttpInterceptor &#123;</span><br><span class="line">    constructor(private cache: CacheService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) &#123;</span><br><span class="line">        // 判断当前请求是否可缓存</span><br><span class="line">        if (!this.isRequestCachable(req)) &#123;</span><br><span class="line">           return next.handle(req);</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取请求对应的缓存对象，若存在则直接返回该请求对象对应的缓存对象</span><br><span class="line">        const cachedResponse = this.cache.get(req);</span><br><span class="line">        if (cachedResponse !== null) &#123;</span><br><span class="line">           return of(cachedResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        // 发送请求至API站点，请求成功后保存至缓存中</span><br><span class="line">        return next.handle(req).pipe(</span><br><span class="line">           tap(event =&gt; &#123;</span><br><span class="line">              if (event instanceof HttpResponse) &#123;</span><br><span class="line">                this.cache.put(req, event);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前请求是否可缓存</span><br><span class="line">    private isRequestCachable(req: HttpRequest&lt;any&gt;) &#123;</span><br><span class="line">        return (req.method === &apos;GET&apos;) &amp;&amp; (req.url.indexOf(CACHABLE_URL) &gt; -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h3><p>app.module.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import DefaultInterceptor</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [BrowserModule, HttpClientModule],</span><br><span class="line">  providers: [</span><br><span class="line">    &#123; provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true &#125;</span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Http进度事件"><a href="#Http进度事件" class="headerlink" title="Http进度事件"></a>Http进度事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.http.get(&apos;url&apos;, &#123;</span><br><span class="line">    observe: &apos;events&apos;,</span><br><span class="line">    reportProgress: true</span><br><span class="line">&#125;).subscribe((event: HttpEvent&lt;any&gt;) =&gt; &#123;</span><br><span class="line">    switch(event.type)&#123;</span><br><span class="line">          case HttpEventType.Sent:</span><br><span class="line">            console.log(&quot;Request sent!&quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.ResponseHeader:</span><br><span class="line">            console.log(&quot;Response header received!&quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.DownloadProgress:</span><br><span class="line">            const kbLoaded = Math.round(event.loaded / 1024);</span><br><span class="line">            console.log(`Download in progress! $&#123;kbLoaded&#125;Kb loaded`);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.Response:</span><br><span class="line">            console.log(&quot;Done!&quot;, event.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request sent!</span><br><span class="line">Response header received!</span><br><span class="line">Download in progress! 6Kb loaded</span><br><span class="line">Download in progress! 24Kb loaded</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.http.get(&apos;url&apos;, &#123;</span><br><span class="line">    observe: &apos;events&apos;,</span><br><span class="line">    reportProgress: true</span><br><span class="line">&#125;).subscribe((event: HttpEvent&lt;any&gt;) =&gt; &#123;</span><br><span class="line">    switch(event.type)&#123;</span><br><span class="line">          case HttpEventType.Sent:</span><br><span class="line">            console.log(&quot;Request sent!&quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.ResponseHeader:</span><br><span class="line">            console.log(&quot;Response header received!&quot;);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.DownloadProgress:</span><br><span class="line">            const kbLoaded = Math.round(event.loaded / 1024);</span><br><span class="line">            console.log(`Download in progress! $&#123;kbLoaded&#125;Kb loaded`);</span><br><span class="line">            break;</span><br><span class="line">          case HttpEventType.Response:</span><br><span class="line">            console.log(&quot;Done!&quot;, event.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request sent!</span><br><span class="line">Response header received!</span><br><span class="line">Download in progress! 6Kb loaded</span><br><span class="line">Download in progress! 24Kb loaded</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GET&quot; class=&quot;headerlink&quot; title=&quot;GET&quot;&gt;&lt;/a&gt;GET&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;设置查询参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
      <category term="http" scheme="http://blog.juphy.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript读写excel文件</title>
    <link href="http://blog.juphy.cn/blogs/1e68471e.html"/>
    <id>http://blog.juphy.cn/blogs/1e68471e.html</id>
    <published>2018-09-04T06:56:00.000Z</published>
    <updated>2018-09-05T01:58:30.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>使用npm</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xlsx -S</span><br></pre></td></tr></table></figure><blockquote><p>直接使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;javascript&quot; src=&quot;xlsx.full.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>老版本浏览器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- add the shim first --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;shim.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- after the shim is referenced, add the library --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;xlsx.full.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Angular-2"><a href="#Angular-2" class="headerlink" title="Angular 2+"></a>Angular 2+</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as XLSX from &apos;xlsx&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>sheet_to_json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* &lt;input type=&quot;file&quot; (change)=&quot;onFileChange($event)&quot; multiple=&quot;false&quot; /&gt; */</span><br><span class="line"></span><br><span class="line">  onFileChange(evt: any) &#123;</span><br><span class="line">    /* wire up file reader */</span><br><span class="line">    const target: DataTransfer = &lt;DataTransfer&gt;(evt.target);</span><br><span class="line">    if (target.files.length !== 1) throw new Error(&apos;Cannot use multiple files&apos;);</span><br><span class="line">    const reader: FileReader = new FileReader();</span><br><span class="line">    reader.onload = (e: any) =&gt; &#123;</span><br><span class="line">      /* read workbook */</span><br><span class="line">      const bstr: string = e.target.result;</span><br><span class="line">      const wb: XLSX.WorkBook = XLSX.read(bstr, &#123;type: &apos;binary&apos;&#125;);</span><br><span class="line"></span><br><span class="line">      /* grab first sheet */</span><br><span class="line">      const wsname: string = wb.SheetNames[0];</span><br><span class="line">      const ws: XLSX.WorkSheet = wb.Sheets[wsname];</span><br><span class="line"></span><br><span class="line">      /* save data */</span><br><span class="line">      this.data = &lt;AOA&gt;(XLSX.utils.sheet_to_json(ws, &#123;header: 1&#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsBinaryString(target.files[0]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>结合Ant Design使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">&lt;nz-upload [nzBeforeUpload]=&quot;beforeUpload&quot;&gt;</span><br><span class="line">   &lt;button nz-button&gt;导入文件&lt;/button&gt;</span><br><span class="line">&lt;/nz-upload&gt;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">reader: FileReader = new FileReader();</span><br><span class="line"></span><br><span class="line">constructor()&#123;</span><br><span class="line">    this.reader.onloadstart=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.reader.onload = (e: any)=&gt;&#123;</span><br><span class="line">        const bstr: string = e.target.result;</span><br><span class="line">        const wb: XLSX.WorkBook = XLSX.read(bstr, &#123;type: &apos;binary&apos;&#125;);</span><br><span class="line">        const sheet = wb.Sheets[wb.SheetNames[0]];</span><br><span class="line">        const json = XLSX.utils.sheet_to_json(sheet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.header.onloadend = () =&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeUpload = (file: UploadFile): boolean =&gt; &#123;</span><br><span class="line">  this.reader.readAsBinaryString(this.file);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>json_to_sheet/aoa_to_sheet</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* generate worksheet */</span><br><span class="line">const ws: XLSX.WorkSheet = XLSX.utils.json_to_sheet(data);</span><br><span class="line">const ws: XLSX.WorkSheet = XLSX.utils.aoa_to_sheet(data);</span><br><span class="line"></span><br><span class="line">/* generate workbook and add the worksheet */</span><br><span class="line">const wb: XLSX.WorkBook = XLSX.utils.book_new();</span><br><span class="line">XLSX.utils.book_append_sheet(wb, ws, &apos;Sheet1&apos;);</span><br><span class="line"></span><br><span class="line">/* save to file */</span><br><span class="line">XLSX.writeFile(wb, &apos;SheetJS.xlsx&apos;);</span><br><span class="line"></span><br><span class="line">或者使用file-saver中的saveAs</span><br><span class="line"></span><br><span class="line">import &#123;saveAs&#125; from &apos;file-save</span><br><span class="line"></span><br><span class="line">const wbout: string = XLSX.write(wb, &#123;bookType: &apos;xlsx&apos;, bookSST: true, type: &apos;binary&apos;&#125;);</span><br><span class="line"></span><br><span class="line">const s2ab = (s: any) =&gt; &#123;</span><br><span class="line">    const buf = new ArrayBuffer(s.length);</span><br><span class="line">    const view = new Uint8Array(buf);</span><br><span class="line">    for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;</span><br><span class="line">    return buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">saveAs(new Blob([s2ab(wbout)], &#123;type: &apos;application/octet-stream&apos;&#125;), &apos;sheetJS.xlsx&apos;);</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest-and-fetch"><a href="#XMLHttpRequest-and-fetch" class="headerlink" title="XMLHttpRequest and fetch"></a>XMLHttpRequest and fetch</h2><blockquote><p>GET</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let xhr = XMLHttpRequest();</span><br><span class="line">req.open(&apos;GET&apos;, &apos;sheetjs.xlsx&apos;, true);</span><br><span class="line">req.onload = function(e)&#123;</span><br><span class="line">    此时req.response是一个ArrayBuffer，通过new Uint8Array()创建不带符号整数的Uint8Array构造函数。</span><br><span class="line">    let data = new Uint8Array(req.response);</span><br><span class="line">    let wb = XLSX.read(data, &#123;type: &quot;array&quot;&#125;);</span><br><span class="line">    document.getElementById(&apos;xxx&apos;).innerHTML = XLSX.units.sheet_to_html(wb.Sheets[wb.SheetNames[0]],&#123;editable: true&#125;).replace(&quot;&lt;table&quot;,&apos;&lt;table id=&quot;table&quot; border=&quot;1&quot;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure><blockquote><p>POST</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let wb = XLSX.utils.table_to_book(document.getElementById(&apos;xxx&apos;));</span><br><span class="line">let fd = new FormData();</span><br><span class="line">let data = XLSX.write(wb, &#123;bookType: &apos;文件格式&apos;, type: &apos;array&apos;&#125;);</span><br><span class="line">fd.append(&apos;data&apos;, new File([data], &apos;文件名&apos;+&apos;.&apos;+&apos;文件格式(csv, xlsx, xls等)&apos;));</span><br><span class="line">req.open(&apos;POST&apos;, url, true);</span><br><span class="line">req.send(fd);</span><br></pre></td></tr></table></figure><blockquote><p>在angular2+中使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.http.get(&apos;sheetjs.xlsx&apos;, &#123;responseType: &apos;arraybuffer&apos;&#125;).subscribe(res =&gt;&#123;</span><br><span class="line">    console.log(res);   // res是ArrayBuffer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let wb = XLSX.utils.table_to_book(document.getElementById(&apos;xxx&apos;));</span><br><span class="line">let fd = new FormData();</span><br><span class="line">let data = XLSX.write(wb, &#123;bookType: &apos;文件格式&apos;, type: &apos;array&apos;&#125;);</span><br><span class="line">fd.append(&apos;data&apos;, new File([data], &apos;文件名.格式名&apos;));</span><br><span class="line">this.http.post(&apos;url&apos;, fd, &#123;&apos;responseType&apos;: &apos;blob&apos;或者&apos;arraybuffer&apos;&#125;).subscribe(res =&gt;&#123;</span><br><span class="line">   console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>nodejs后端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.post(&apos;/upload&apos;, (req, res) =&gt;&#123;</span><br><span class="line">    res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">    let f = req.files[Object.keys(req.files)[0]];</span><br><span class="line">    // f.name 生成的excel的名字和格式</span><br><span class="line">    let newpath = path.join(__dirname, f.name); // 定义新文件所在的位置</span><br><span class="line">    fs.renameSync(f.path, newpath);</span><br><span class="line">    re.end(&apos;xx&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="其他使用功能"><a href="#其他使用功能" class="headerlink" title="其他使用功能"></a>其他使用功能</h2><blockquote><p>修改某一单元的数据，合并单元格问题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ws: any = XLSX.utils.json_to_sheet(data);</span><br><span class="line">// 修改填充的数据</span><br><span class="line">ws[&apos;A1&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line">ws[&apos;A2&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line">ws[&apos;A3&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 合并单元格</span><br><span class="line">/*</span><br><span class="line">c: 代表纵向，从0开始</span><br><span class="line">r: 代表横向，从0开始</span><br><span class="line">*/</span><br><span class="line">ws[&apos;!merges&apos;]=[</span><br><span class="line">    &#123;</span><br><span class="line">    s: &#123;c: 0, r: 0&#125;,</span><br><span class="line">    e: &#123;c: 10, r: 0&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    s: &#123;c: 1, r: 0&#125;,</span><br><span class="line">    e: &#123;c: 1, r: 10&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>单元格</p></blockquote><table><thead><tr><th style="text-align:center">Key</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td style="text-align:center">原始值</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">格式化文本</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">type: b Boolean, e Error, n Number, d Date, s Text, z Stub</td></tr></tbody></table><blockquote><p>多种导出形式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; Importing:</span><br><span class="line">aoa_to_sheet converts an array of arrays of JS data to a worksheet.</span><br><span class="line">json_to_sheet converts an array of JS objects to a worksheet.</span><br><span class="line">table_to_sheet converts a DOM TABLE element to a worksheet.</span><br><span class="line">sheet_add_aoa adds an array of arrays of JS data to an existing worksheet.</span><br><span class="line">sheet_add_json adds an array of JS objects to an existing worksheet.</span><br><span class="line"></span><br><span class="line">&gt; Exporting:</span><br><span class="line">sheet_to_json converts a worksheet object to an array of JSON objects.</span><br><span class="line">sheet_to_csv generates delimiter-separated-values output.</span><br><span class="line">sheet_to_txt generates UTF16 formatted text.</span><br><span class="line">sheet_to_html generates HTML output.</span><br><span class="line">sheet_to_formulae generates a list of the formulae (with value fallbacks).</span><br><span class="line"></span><br><span class="line">&gt; Cell and cell address manipulation:</span><br><span class="line">format_cell generates the text value for a cell (using number formats).</span><br><span class="line">encode_row / decode_row converts between 0-indexed rows and 1-indexed rows.</span><br><span class="line">encode_col / decode_col converts between 0-indexed columns and column names.</span><br><span class="line">encode_cell / decode_cell converts cell addresses.</span><br><span class="line">encode_range / decode_range converts cell ranges.</span><br></pre></td></tr></table></figure><p><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">详细使用SheetJS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用npm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
      <category term="nodejs" scheme="http://blog.juphy.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Angular管道</title>
    <link href="http://blog.juphy.cn/blogs/c64e9b3c.html"/>
    <id>http://blog.juphy.cn/blogs/c64e9b3c.html</id>
    <published>2018-09-02T06:56:00.000Z</published>
    <updated>2018-09-04T04:18:40.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内置管道"><a href="#内置管道" class="headerlink" title="内置管道"></a>内置管道</h2><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;&apos;Angular&apos; | uppercase&#125;&#125;&lt;/p&gt; // ANGULAR</span><br><span class="line">&lt;p&gt;&#123;&#123;&apos;Angular&apos; | lowercase&#125;&#125;&lt;/p&gt; // angular</span><br></pre></td></tr></table></figure><h3 id="数值格式化"><a href="#数值格式化" class="headerlink" title="数值格式化"></a>数值格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi: number = 3.14</span><br><span class="line">e: number = 2.718281828</span><br><span class="line">&lt;p&gt;&#123;&#123;e | number: &apos;3.1-5&apos;&#125;&#125;&lt;/p&gt; // 002.71828</span><br><span class="line">&lt;p&gt;&#123;&#123;e | number: &apos;4.5-5&apos;&#125;&#125;&lt;/p&gt; // 0,002.71828</span><br><span class="line">&lt;p&gt;&#123;&#123;e | number: &apos;4.0&apos;&#125;&#125;&lt;/p&gt; // 0,002.718</span><br><span class="line">&lt;p&gt;&#123;&#123;e | number: &apos;4.&apos;&#125;&#125;&lt;/p&gt; // 0,002.718</span><br></pre></td></tr></table></figure><p><code>{minIntegerDigits}.{minFractionDigits}-{maxfractionDigits}</code></p><ul><li>minIntegerDigits：整数部分保留最小的位数，默认值为1.</li><li>minFractionDigits：小数部分保留最小的位数，默认值为0.</li><li>maxFractionDigits：小数部分保留最大的位数，默认值为3.<br>小数点左边的数字表示最少保留的位数，如果原数值整数位不足，则用0补齐；小数点右边表示小数的最小位数和小数的最大位数，如果原值的小数位大于最大位数，要四舍五入保留到最大位数；如果原值的小数位小于最小位数，则要不足小数位补0。<h3 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h3></li></ul><table><thead><tr><th style="text-align:left">日期</th><th style="text-align:left">标志符</th><th style="text-align:left">缩写</th><th style="text-align:left">全称</th><th style="text-align:left">单标志符</th><th style="text-align:left">双标志符</th></tr></thead><tbody><tr><td style="text-align:left">地区</td><td style="text-align:left">G</td><td style="text-align:left">G(AD)</td><td style="text-align:left">GGGG(Anno Domini)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">年</td><td style="text-align:left">y</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">y(2016)</td><td style="text-align:left">yy(16)</td></tr><tr><td style="text-align:left">月</td><td style="text-align:left">M</td><td style="text-align:left">MMM(Jun)</td><td style="text-align:left">MMMM(June)</td><td style="text-align:left">M(6)</td><td style="text-align:left">MM(06)</td></tr><tr><td style="text-align:left">日</td><td style="text-align:left">d</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">d(8)</td><td style="text-align:left">dd(08)</td></tr><tr><td style="text-align:left">星期</td><td style="text-align:left">E</td><td style="text-align:left">E,EE,EEE(Fri)</td><td style="text-align:left">EEEE(Friday)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">时间(AM,PM)</td><td style="text-align:left">j</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">j(8 PM)</td><td style="text-align:left">jj(08 PM)</td></tr><tr><td style="text-align:left">12小时制</td><td style="text-align:left">h</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">h(8)</td><td style="text-align:left">hh(08)</td></tr><tr><td style="text-align:left">24小时制</td><td style="text-align:left">H</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">H(20)</td><td style="text-align:left">HH(20)</td></tr><tr><td style="text-align:left">分</td><td style="text-align:left">m</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">m(5)</td><td style="text-align:left">mm(05)</td></tr><tr><td style="text-align:left">秒</td><td style="text-align:left">s</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">s(8)</td><td style="text-align:left">ss(08)</td></tr><tr><td style="text-align:left">时区</td><td style="text-align:left">Z</td><td style="text-align:left"></td><td style="text-align:left">Z(china Standard Time)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">时区</td><td style="text-align:left">z</td><td style="text-align:left">z(GMT-8:00)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date:Date = new Date(&apos;2016-06-08 20:05:08&apos;);</span><br><span class="line">&lt;p&gt;&#123;&#123;date | date: &quot;y-MM-dd EEEE&quot;&#125;&#125;&lt;/p&gt; //2016-06-08 Wednesday</span><br></pre></td></tr></table></figure><h3 id="PercentPipe"><a href="#PercentPipe" class="headerlink" title="PercentPipe"></a>PercentPipe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 0.269</span><br><span class="line">&lt;p&gt;&#123;&#123;a | percent&#125;&#125;&lt;/p&gt; // 27%</span><br><span class="line">&lt;p&gt;&#123;&#123;a | percent:&apos;4.3-5&apos;&#125;&#125;&lt;/p&gt; // 0,026.900%</span><br></pre></td></tr></table></figure><p><code>{ value_expression | percent [:digitsInfo[:locale]] }</code><br>如果没有digitsInfo则按照整数取（四舍五入），如果有digitsInfo，则按照规则取。</p><h3 id="CurrencyPipe"><a href="#CurrencyPipe" class="headerlink" title="CurrencyPipe"></a>CurrencyPipe</h3><p><code>expression | currency[: currencyCode[: display[: digitInfo]]]</code></p><ul><li>currency 要显示内容（如’USD’，也可以是自定义的）</li><li>currencyCode<ul><li>‘code’ 显示内容（如’USD’）</li><li>‘symbol’（默认） 显示符号（例如$）</li><li>‘symbol-narrow’</li><li>布尔值 true用于符号 false用于code</li></ul></li><li>digitInfo 按照数值的规则</li></ul><h3 id="SlicePipe（非纯管道）"><a href="#SlicePipe（非纯管道）" class="headerlink" title="SlicePipe（非纯管道）"></a>SlicePipe（非纯管道）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = &apos;abcdefghij&apos;;</span><br><span class="line">&lt;p&gt;&#123;&#123;str | slice:0:4&#125;&#125;&lt;/p&gt; // &apos;abcd&apos;</span><br><span class="line">&lt;p&gt;&#123;&#123;str | slice:4:0&#125;&#125;&lt;/p&gt; // &apos;&apos;</span><br><span class="line">&lt;p&gt;&#123;&#123;str | slice:-4&#125;&#125;&lt;/p&gt; // &apos;ghij&apos;</span><br></pre></td></tr></table></figure><h3 id="JsonPipe（非纯管道）"><a href="#JsonPipe（非纯管道）" class="headerlink" title="JsonPipe（非纯管道）"></a>JsonPipe（非纯管道）</h3><p>将数据对象通过JSON.stringify()转换成对象字符串，并不改变原数据。</p><h2 id="管道分类"><a href="#管道分类" class="headerlink" title="管道分类"></a>管道分类</h2><h3 id="纯管道"><a href="#纯管道" class="headerlink" title="纯管道"></a>纯管道</h3><p>仅当管道输入值变化的时候，才执行转换操作，默认的类型是 pure 类型。（备注：输入值变化是指原始数据类型如：string、number、boolean、Symbol等的数值发生变化或者对对象引用（Date、Array、Function、Object）的更改）。Angular会忽略对象内部的更改，除非是引用地址的变化。</p><p>纯管道使用纯函数， 纯函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 给定相同的输入，它们总是返回相同的输出。</p><h3 id="非纯管道"><a href="#非纯管道" class="headerlink" title="非纯管道"></a>非纯管道</h3><p>angular组件在每次变化检测期间都会执行，如鼠标点击或移动都会执行 impure 管道。非纯管道可能会被调用很多次，因此必须小心使用非纯管道。</p><p>将管道设置为非纯管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Pipe(&#123;</span><br><span class="line">    name: &apos;SexReformPipe&apos;,</span><br><span class="line">    pure: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="管道链"><a href="#管道链" class="headerlink" title="管道链"></a>管道链</h2><p>将多个管道用<code>|</code>连接在一起，组成管道链对数据进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;&apos;abcdefgh&apos; | slice:0:3 | uppercase&#125;&#125;&lt;/p&gt;  // &apos;ABC&apos;</span><br></pre></td></tr></table></figure></p><h2 id="自定义管道"><a href="#自定义管道" class="headerlink" title="自定义管道"></a>自定义管道</h2><ul><li>@Pipe装饰器定义Pipe的metadata信息</li><li>实现PipeTransform接口中定义的transform方法，接受一个输入值和一些可选参数，并返回转换后的值</li><li>不可以返回html</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Pipe, PipeTransform &#125; form &apos;@angular/core&apos;</span><br><span class="line">@Pipe(&#123;name: &apos;exponentialStrength&apos;&#125;)</span><br><span class="line">export class ExponentialStrengthPipe implements PipeTransform &#123;</span><br><span class="line">  transform(value: number, exponent: string): number &#123;</span><br><span class="line">    let exp = parseFloat(exponent);</span><br><span class="line">    return Math.pow(value, isNaN(exp) ? 1 : exp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Pipe(&#123; name: &apos;sexReform&apos; &#125;)</span><br><span class="line">export class SexReformPipe implements PipeTransform &#123;</span><br><span class="line">    transform(value: string):string&#123;</span><br><span class="line">        switch(value)&#123;</span><br><span class="line">            case &apos;male&apos;: return &apos;男&apos;;</span><br><span class="line">            case &apos;female&apos;: return &apos;女&apos;;</span><br><span class="line">            default: return &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自定义管道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Super power boost: &#123;&#123;2 | exponentialStrength: 10&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;sexValue | sexReform&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;&#123;&#123;sexValue | sexReform&#125;&#125;&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p><code>定义完管道之后，要手动注册自定义管道，添加到declarations数组中</code>。</p><h3 id="非纯AsyncPipe"><a href="#非纯AsyncPipe" class="headerlink" title="非纯AsyncPipe"></a>非纯AsyncPipe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; Observable, interval &#125; from &apos;rxjs&apos;;</span><br><span class="line">import &#123; map, take &#125; from &apos;rxjs/operators&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;app-hero-message&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h2&gt;Async Hero Message and AsyncPipe&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;Message: &#123;&#123; message$ | async &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button (click)=&quot;resend()&quot;&gt;Resend&lt;/button&gt;`,</span><br><span class="line">&#125;)</span><br><span class="line">export class HeroAsyncMessageComponent &#123;</span><br><span class="line">  message$: Observable&lt;string&gt;;</span><br><span class="line"></span><br><span class="line">  private messages = [</span><br><span class="line">    &apos;You are my hero!&apos;,</span><br><span class="line">    &apos;You are the best hero!&apos;,</span><br><span class="line">    &apos;Will you be my hero?&apos;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  constructor() &#123; this.resend(); &#125;</span><br><span class="line"></span><br><span class="line">  resend() &#123;</span><br><span class="line">    this.message$ = interval(500).pipe(</span><br><span class="line">      map(i =&gt; this.messages[i]),</span><br><span class="line">      take(this.messages.length)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncPipe接受一个Promise或Observable作为输入，并且自动订阅这个输入，最终返回他们给出的值。AsyncPipe 管道是有状态的。 该管道维护着一个所输入的 Observable 的订阅，并且持续从那个 Observable 中发出新到的值。</p><h3 id="非纯且带缓存的管道"><a href="#非纯且带缓存的管道" class="headerlink" title="非纯且带缓存的管道"></a>非纯且带缓存的管道</h3><p>一个向服务器发起http请求的非纯管道。此管道只有在所请求的URL发生变化时才会向服务器发起请求，他会缓存服务器的响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Pipe, PipeTransform &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; HttpClient &#125;          from &apos;@angular/common/http&apos;;</span><br><span class="line">@Pipe(&#123;</span><br><span class="line">  name: &apos;fetch&apos;,</span><br><span class="line">  pure: false</span><br><span class="line">&#125;)</span><br><span class="line">export class FetchJsonPipe  implements PipeTransform &#123;</span><br><span class="line">  private cachedData: any = null;</span><br><span class="line">  private cachedUrl = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">  constructor(private http: HttpClient) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  transform(url: string): any &#123;</span><br><span class="line">    if (url !== this.cachedUrl) &#123;</span><br><span class="line">      this.cachedData = null;</span><br><span class="line">      this.cachedUrl = url;</span><br><span class="line">      this.http.get(url).subscribe( result =&gt; this.cachedData = result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.cachedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个组件中使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;app-hero-list&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h2&gt;Heroes from JSON File&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div *ngFor=&quot;let hero of (&apos;assets/heroes.json&apos; | fetch) &quot;&gt;</span><br><span class="line">      &#123;&#123;hero.name&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;Heroes as JSON:</span><br><span class="line">      &#123;&#123;&apos;assets/heroes.json&apos; | fetch | json&#125;&#125;</span><br><span class="line">    &lt;/p&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">export class HeroListComponent &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>assets/heroes.json</code>的数据是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Windstorm&quot;, &quot;canFly&quot;: true&#125;,</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Bombasto&quot;,  &quot;canFly&quot;: false&#125;,</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Magneto&quot;,   &quot;canFly&quot;: false&#125;,</span><br><span class="line">  &#123;&quot;name&quot;: &quot;Tornado&quot;,   &quot;canFly&quot;: true&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>最终结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Heros from JSON File</span><br><span class="line"></span><br><span class="line">Windstorm</span><br><span class="line">Bombasto</span><br><span class="line">Magneto</span><br><span class="line">Tornado</span><br><span class="line"></span><br><span class="line">Heroes as JSON: [ &#123; &quot;name&quot;: &quot;Windstorm&quot;, &quot;canFly&quot;: true &#125;, &#123; &quot;name&quot;: &quot;Bombasto&quot;, &quot;canFly&quot;: false &#125;, &#123; &quot;name&quot;: &quot;Magneto&quot;, &quot;canFly&quot;: false &#125;, &#123; &quot;name&quot;: &quot;Tornado&quot;, &quot;canFly&quot;: true &#125; ]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内置管道&quot;&gt;&lt;a href=&quot;#内置管道&quot; class=&quot;headerlink&quot; title=&quot;内置管道&quot;&gt;&lt;/a&gt;内置管道&lt;/h2&gt;&lt;h3 id=&quot;大小写转换&quot;&gt;&lt;a href=&quot;#大小写转换&quot; class=&quot;headerlink&quot; title=&quot;大小写转换&quot;&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
      <category term="pipe" scheme="http://blog.juphy.cn/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类型转换</title>
    <link href="http://blog.juphy.cn/blogs/46b44a0a.html"/>
    <id>http://blog.juphy.cn/blogs/46b44a0a.html</id>
    <published>2018-08-31T03:22:00.000Z</published>
    <updated>2018-08-31T06:01:46.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>通过手动进行类型转换，Javascript提供了以下转型函数：</p><ul><li>转换为数值类型：Number(mix)、parseInt(string,radix)、parseFloat(string)</li><li>转换为字符串类型：toString(radix)、String(mix)</li><li>转换为布尔类型：Boolean(mix)</li></ul><blockquote><p>1、Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为：</p></blockquote><ul><li>（1）如果是布尔值，true和false分别被转换为1和0</li><li>（2）如果是数字值，返回本身。</li><li>（3）如果是null，返回0.</li><li>（4）如果是undefined，返回NaN。</li><li>（5）如果是字符串，遵循以下规则：<ul><li>1、如果字符串中只包含数字，则将其转换为十进制（忽略前导0）</li><li>2、如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0）</li><li>3、如果是空字符串，将其转换为0</li><li>4、如果字符串中包含非以上格式，则将其转换为NaN</li></ul></li><li>（6）如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。</li></ul><p>下表列出了对象的valueOf()的返回值：</p><table><thead><tr><th style="text-align:left">对象</th><th style="text-align:left">返回值</th></tr></thead><tbody><tr><td style="text-align:left">Array</td><td style="text-align:left">数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。</td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:left">Boolean 值。</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td style="text-align:left">Function</td><td style="text-align:left">函数本身。</td></tr><tr><td style="text-align:left">Number</td><td style="text-align:left">数字值。</td></tr><tr><td style="text-align:left">Object</td><td style="text-align:left">对象本身。这是默认情况。 “[object Object]”</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">字符串值。</td></tr></tbody></table><blockquote><p>2、parseInt(string, radix)函数，将字符串转换为整数类型的数值。它也有一定的规则：</p></blockquote><ul><li>（1）忽略字符串前面的空格，直至找到第一个非空字符</li><li>（2）如果第一个字符不是数字符号或者负号，返回NaN</li><li>（3）如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止</li><li>（4）如果上步解析的结果以0开头，则将其当作八进制来解析；如果以0x开头，则将其当作十六进制来解析</li><li>（5）如果指定radix参数，则以radix为基数进行解析</li></ul><blockquote><p>3、parseFloat(string)函数，将字符串转换为浮点数类型的数值。</p></blockquote><p>它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。</p><blockquote><p>4、toString(radix)方法。除undefined和null之外的所有类型的值都具有toString()方法，其作用是返回对象的字符串表示。</p></blockquote><table><thead><tr><th style="text-align:left">对象</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">Array</td><td style="text-align:left">将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。</td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:left">如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">返回日期的文字表示法。</td></tr><tr><td style="text-align:left">Error</td><td style="text-align:left">返回一个包含相关错误信息的字符串。</td></tr><tr><td style="text-align:left">Function</td><td style="text-align:left">返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] }</td></tr><tr><td style="text-align:left">Number</td><td style="text-align:left">返回数字的文字表示。</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">返回 String 对象的值。</td></tr><tr><td style="text-align:left">默认</td><td style="text-align:left">返回 “[object objectname]”，其中 objectname 是对象类型的名称。</td></tr></tbody></table><blockquote><p>5、String(mix)函数，将任何类型的值转换为字符串，其规则为：</p></blockquote><ul><li>（1）如果有toString()方法，则调用该方法（不传递radix参数）并返回结果</li><li>（2）如果是null，返回”null”</li><li>（3）如果是undefined，返回”undefined”</li></ul><blockquote><p>6、Boolean(mix)函数，将任何类型的值转换为布尔值。</p></blockquote><p>以下值会被转换为false：false、””、0、NaN、null、undefined，其余任何值都会被转换为true。</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>在某些情况下，即使我们不提供显示转换，Javascript也会进行自动类型转换，主要情况有：</p><blockquote><p>1、于检测是否为非数值的函数：isNaN(mix)</p></blockquote><p>isNaN()函数，经测试发现，该函数会尝试将参数值用Number()进行转换，如果结果为“非数值”则返回true，否则返回false。</p><blockquote><p>2、递增递减操作符（包括前置和后置）、一元正负符号操作符</p></blockquote><p>这些操作符适用于任何数据类型的值，针对不同类型的值，该操作符遵循以下规则（经过对比发现，其规则与Number()规则基本相同）：</p><ul><li>（1）如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同Number()），在执行加减1的操作，字符串变量变为数值变量。</li><li>（2）如果是不包含有效数字字符的字符串，将变量的值设置为NaN，字符串变量变成数值变量。</li><li>（3）如果是布尔值false，先将其转换为0再执行加减1的操作，布尔值变量编程数值变量。</li><li>（4）如果是布尔值true，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量。</li><li>（5）如果是浮点数值，执行加减1的操作。</li><li>（6）如果是对象，先调用对象的valueOf()方法，然后对该返回值应用前面的规则。如果结果是NaN，则调用toString()方法后再应用前面的规则。对象变量变成数值变量。</li></ul><blockquote><p>3、 加法运算操作符</p></blockquote><p>加号运算操作符在Javascript也用于字符串连接符，所以加号操作符的规则分两种情况：</p><ul><li>如果两个操作值都是数值，其规则为：<ul><li>(1)如果一个操作数为NaN，则结果为NaN</li><li>(2)如果是Infinity+Infinity，结果是Infinity</li><li>(3)如果是-Infinity+(-Infinity)，结果是-Infinity</li><li>(4)如果是Infinity+(-Infinity)，结果是NaN</li><li>(5)如果是+0+(+0)，结果为+0</li><li>(6)如果是(-0)+(-0)，结果为-0</li><li>(7)如果是(+0)+(-0)，结果为+0</li></ul></li><li>如果有一个操作值为字符串，则：<ul><li>如果两个操作值都是字符串，则将它们拼接起来</li><li>如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来</li><li>如果一个操作数是对象、数组或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。</li></ul></li></ul><p>在加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。</p><blockquote><p>4、 乘除、减号运算符、取模运算符</p></blockquote><p>这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用Number()函数进行转换。具体每一种运算的详细规则请参考ECMAScript中的定义。</p><blockquote><p>5、 逻辑操作符（!、&amp;&amp;、||）</p></blockquote><ul><li>逻辑非（！）操作符首先通过Boolean()函数将它的操作值转换为布尔值，然后求反。</li><li>逻辑与（&amp;&amp;）操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换：<ul><li>（1）如果第一个操作数经Boolean()转换后为true，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值）</li><li>（2）如果有一个操作值为null，返回null</li><li>（3）如果有一个操作值为NaN，返回NaN</li><li>（4）如果有一个操作值为undefined，返回undefined</li></ul></li><li>逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则：<ul><li>（1）如果第一个操作值经Boolean()转换后为false，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值）</li><li>（2）对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同</li></ul></li></ul><blockquote><p>6、 关系操作符（&lt;, &gt;, &lt;=, &gt;=）</p></blockquote><p>与上述操作符一样，关系操作符的操作值也可以是任意类型的，所以使用非数值类型参与比较时也需要系统进行隐式类型转换：<br>（1）如果两个操作值都是数值，则进行数值比较<br>（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值<br>（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较<br>（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较<br>（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较<br>注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。</p><blockquote><p>7、 相等操作符（==）</p></blockquote><p>相等操作符会对操作值进行隐式转换后进行比较：<br>（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值<br>（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值<br>（3）如果一个操作值是对象（包括数组，对象所有的引用类型的值），另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较<br>（4）null与undefined是相等的<br>（5）如果一个操作值为NaN，则相等比较返回false<br>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象</p><p>举例说明：</p><p>[1,2]+[3,4] == “1,23,4”</p><p>[1,2,{}] == “1,2,[object, Object]”</p><p>[]+[] == ‘’</p><p>[]+{} == ‘[object Object]’</p><p>{}+{} == NaN （在firefox中，javascript把第一个{}解释成空的代码块，并忽略了它，NaN其实就是+{}的计算结果，这里的+号不是二元运算符，而是一元运算符，作用是将它后面的操作数转换成数字）</p><p>{}+{} == “[object Object][object Object]”</p><p>+”3.65” == 3.65</p><p>++[[]][+[]]+[+[]] == ‘10’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;显式转换&quot;&gt;&lt;a href=&quot;#显式转换&quot; class=&quot;headerlink&quot; title=&quot;显式转换&quot;&gt;&lt;/a&gt;显式转换&lt;/h2&gt;&lt;p&gt;通过手动进行类型转换，Javascript提供了以下转型函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转换为数值类型：Number(mi
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="类型转换" scheme="http://blog.juphy.cn/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>nodejs文件路径问题</title>
    <link href="http://blog.juphy.cn/blogs/a549916c.html"/>
    <id>http://blog.juphy.cn/blogs/a549916c.html</id>
    <published>2018-08-28T03:22:00.000Z</published>
    <updated>2018-08-30T09:45:56.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process-cwd"><a href="#process-cwd" class="headerlink" title="process.cwd()"></a>process.cwd()</h2><p>获取node命令启动路径，其值与代码所在位置无关，即<code>运行node命令时所在的文件夹的绝对路径</code>。</p><p>File System模块使用相对路径读写文件时，参考的就是这个路径。适用于开发命令行程序时，读取命令启动位置目录的文件。</p><h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><p>被执行的js所在的文件夹的绝对路径</p><h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><p>被执行的js的绝对路径</p><h2 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h2><p>只有在require时才使用相对路径(./，../)的引用方法。require的使用效果是跟__dirname的效果相同，不会因为启动脚本的目录不一样而改变。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">G://</span><br><span class="line">- angular/</span><br><span class="line">    - server/</span><br><span class="line">        - main.js</span><br><span class="line">        - api.js</span><br><span class="line">    - spider/</span><br><span class="line">        - mono.js</span><br><span class="line">        - one.js     </span><br><span class="line"></span><br><span class="line">运行代码：</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">console.log(__dirname);</span><br><span class="line">console.log(__filename);</span><br><span class="line">console.log(process.cwd());</span><br><span class="line">console.log(path.resolve(&apos;./&apos;));</span><br></pre></td></tr></table></figure><p>以下结果都是运行main.js所得：</p><ul><li><p>在server文件夹下，输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G:\angular\server</span><br><span class="line">G:\angular\server\main.js</span><br><span class="line">G:\angular\server</span><br><span class="line">G:\angular\server</span><br></pre></td></tr></table></figure></li><li><p>在angular文件下，输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G:\angular\server</span><br><span class="line">G:\angular\server\main.js</span><br><span class="line">G:\angular</span><br><span class="line">G:\angular</span><br></pre></td></tr></table></figure></li><li><p>获取相同目录下的其他文件</p><ul><li>path.join(path.dirname(__filename) + ‘/api.js’)</li><li>path.resolve(__dirname + ‘/api.js’)</li></ul></li></ul><p>此时，不管是在angular文件夹下，还是server文件夹下，两者的结果都是<code>G:\angular\server\api.js</code>。</p><ul><li>获取相邻目录下的文件<ul><li>在windows下<code>path.resolve(__dirname , &#39;../spider/mono.js</code>，两种文件夹下运行结果一致；</li><li>在Linux的centos7下，两者结果不一致。angular文件夹下会报错<ul><li>如果在angular文件夹下，使用<code>path.resolve(path.resolve(&#39;./&#39;) + &#39;/spider/mono.js&#39;)</code>，或者<code>path.resolve(process.cwd() + &#39;/spider/mono.js&#39;)</code>；</li><li>如果在server文件夹下，使用<code>path.resolve(__dirname , &#39;../spider/mono.js&#39;)</code>; </li></ul></li></ul></li></ul><h2 id="path-resolve和path-join的区别"><a href="#path-resolve和path-join的区别" class="headerlink" title="path.resolve和path.join的区别"></a>path.resolve和path.join的区别</h2><ul><li>path.join 全部给定的 path 片段连接到一起，并规范化生成的路径。如果<code>连接后的路径字符串</code>是一个长度为零的字符串，则代表返回 ‘.’，表示当前工作目录。不会对’/‘进行解读</li><li>path.resolve 把一个路径或路径片段的序列解析为一个绝对路径，会将’/‘当成根目录。</li></ul><p>两者都是正常解读’..’和’.’。</p><p>假设在G://angular；</p><ul><li>path.join(‘a’, ‘b’, ‘c’)    //  ‘a/b/c’</li><li>path.join(‘a’, ‘b’, ‘..’, ‘c’)      //  ‘a/c’</li><li>path.resolve(‘a’, ‘b’, ‘..’, ‘c’)       //  G://a/c</li><li>path.resolve(‘/a’, ‘/b’, ‘..’, ‘c’)       //  G://c</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;process-cwd&quot;&gt;&lt;a href=&quot;#process-cwd&quot; class=&quot;headerlink&quot; title=&quot;process.cwd()&quot;&gt;&lt;/a&gt;process.cwd()&lt;/h2&gt;&lt;p&gt;获取node命令启动路径，其值与代码所在位置无关，即&lt;cod
      
    
    </summary>
    
      <category term="node" scheme="http://blog.juphy.cn/categories/node/"/>
    
    
      <category term="path" scheme="http://blog.juphy.cn/tags/path/"/>
    
  </entry>
  
  <entry>
    <title>python3发起http请求</title>
    <link href="http://blog.juphy.cn/blogs/664a0ac7.html"/>
    <id>http://blog.juphy.cn/blogs/664a0ac7.html</id>
    <published>2018-08-24T03:22:00.000Z</published>
    <updated>2018-08-30T09:45:56.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><blockquote><p>python内置的标准库模块</p></blockquote><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">url = &apos;https://api.github.com/users/github&apos;</span><br><span class="line">f = urllib.request.urlopen(url)</span><br><span class="line">// html或者json数据都可以解析</span><br><span class="line">print(f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure><p>利用type(f)可以查看输出响应的类型，<code>&lt;class &#39;http.client.HTTPResponse&#39;&gt;</code>，它是一个HTTPResponse类型的对象，它主要包括read()、readinto()、getheader(name)、getheaders()、fileno()等方法，以及msg、version、status、reason、debuglevel、closed等属性。</p><ul><li>调用read()方法可以得到返回的网页内容</li><li>调用status属性可以得到返回结果的状态码，如200代表请求成功，404代表网页未找到等</li><li>getheaders()响应头信息</li></ul><p><code>urlopen()</code>也可以传递参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</span><br></pre></td></tr></table></figure></p><ul><li>data<br>data参数是可选的。如果要添加该参数，并且如果它是字节流编码格式的内容，即bytes类型，则需要通过bytes()方法转化。另外，如果传递了这个参数，则它的请求方式就不再是GET方式，而是POST方式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line">import urllib.request</span><br><span class="line"> </span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;&apos;word&apos;: &apos;hello&apos;&#125;), encoding=&apos;utf8&apos;)</span><br><span class="line">response = urllib.request.urlopen(&apos;http://httpbin.org/post&apos;, data=data)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;)) // 如果不加decode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;data&quot;: &quot;&quot;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;word&quot;: &quot;hello&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;identity&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Content-Length&quot;: &quot;10&quot;,</span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Python-urllib/3.6&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: null,</span><br><span class="line">  &quot;origin&quot;: &quot;61.148.29.62&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递的参数{word: ‘hello’}，它需要被转码成bytes（字节流）类型。其中转字节流采用了bytes()方法，该方法的第一个参数需要是str（字符串）类型，需要用urllib.parse模块里的urlencode()方法来将参数字典转化为字符串；第二个参数指定编码格式，这里指定为utf8。</p><ul><li>timeout<br>用于设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。它支持HTTP、HTTPS、FTP请求。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"> </span><br><span class="line">response = urllib.request.urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)</span><br><span class="line">print(response.read())</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">超时报错，服务器没有响应，于是抛出了URLError异常。该异常属于urllib.error模块，错误原因是超时。</span><br></pre></td></tr></table></figure><p>可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用try except语句来实现，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import urllib.request</span><br><span class="line">import urllib.error</span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    response = urllib.request.urlopen(&apos;http://httpbin.org/get&apos;, timeout=0.1)</span><br><span class="line">except urllib.error.URLError as e:</span><br><span class="line">    if isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(&apos;TIME OUT&apos;)</span><br></pre></td></tr></table></figure></p><p><a href="https://docs.python.org/3/library/urllib.request.html" target="_blank" rel="noopener">更多urlopen的用法</a></p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>简单的请求可以使用urlopen，如果需要在请求中加入Headers等信息，就可以使用更强大的Request类来构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"> </span><br><span class="line">request = urllib.request.Request(&apos;https://python.org&apos;)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>依然是使用urlopen发送请求，只不过参数不再是url，而是一个request类型的对象。</p><blockquote><p>class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)</p></blockquote><ul><li>url 这是必选，其他事可选</li><li>data 必须是bytes（字节流）类型，如果是字典，可以先用urllib.parse模块里的urlencode()编码。</li><li>headers 可以在构造请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加。</li><li>origin_req_host 指的是请求方的host名称或者IP地址。</li><li>unverifiable表示这个请求是否是无法验证的，默认是False，意思就是说用户没有足够权限来选择接收这个请求的结果。</li><li>method是一个字符串，用来指示请求使用的方法，比如GET、POST和PUT等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"> </span><br><span class="line">url = &apos;http://httpbin.org/post&apos;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;,</span><br><span class="line">    &apos;Host&apos;: &apos;httpbin.org&apos;</span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    &apos;name&apos;: &apos;Germey&apos;</span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict), encoding=&apos;utf8&apos;)</span><br><span class="line">req = request.Request(url=url, data=data, headers=headers, method=&apos;POST&apos;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">url即请求URL，headers中指定了User-Agent和Host，参数data用urlencode()和bytes()方法转成字节流。另外，指定了请求方式为POST。</span><br></pre></td></tr></table></figure></li></ul><p>或者使用add_header()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req = request.Request(url=url, data=data, method=&apos;POST&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h2><blockquote><p>由urllib3提供支持，Requests抽象了大量的程式化的代码，使得http请求比使用内置urllib库更简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 安装requests，pip install requests</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">from pprint import pprint</span><br><span class="line"></span><br><span class="line">r = requests.get(url)</span><br><span class="line">pprint(r.json())</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;urllib&quot;&gt;&lt;a href=&quot;#urllib&quot; class=&quot;headerlink&quot; title=&quot;urllib&quot;&gt;&lt;/a&gt;urllib&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;python内置的标准库模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="python3" scheme="http://blog.juphy.cn/categories/python3/"/>
    
    
      <category term="urllib" scheme="http://blog.juphy.cn/tags/urllib/"/>
    
      <category term="requests" scheme="http://blog.juphy.cn/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>Referer</title>
    <link href="http://blog.juphy.cn/blogs/9a610f19.html"/>
    <id>http://blog.juphy.cn/blogs/9a610f19.html</id>
    <published>2018-08-23T08:22:00.000Z</published>
    <updated>2018-08-30T09:45:56.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Referer"><a href="#什么是Referer" class="headerlink" title="什么是Referer?"></a>什么是Referer?</h2><blockquote><p>Referer[sic] 请求头字段允许由客户端指定资源的 URI 来自于哪一个请求地址，这对服务器有好处（应该是 “referrer” 这个字段拼错了）。Referer 请求头让服务器能够拿到请求资源的来源，可以用于分析用户的兴趣爱好、收集日志、优化缓存等等。同时也让服务器能够发现过时的和错误的链接并及时维护。</p></blockquote><p>Referer是HTTP请求header的一部分，当浏览器向web服务器发送请求的时候，头信息里包含有Referer。Request Headers中有一个Referer字段，对应的信息表示一个来源。</p><h2 id="Referer的作用？"><a href="#Referer的作用？" class="headerlink" title="Referer的作用？"></a>Referer的作用？</h2><ul><li>防盗链</li></ul><p>如果我在<code>www.a.com</code>里有一个<code>www.b.com</code>链接，那么访问<code>www.b.com</code>时，它的Request Headers中有Referer: <code>www.a.com</code>，可以利用这个来防止盗链了，比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是<code>www.a.com</code>，那么图片服务器每次取到Referer来判断一下是不是我自己的域名<code>www.a.com</code>，如果是就继续访问，不是就拦截。</p><ul><li>获取访问来源，统计访问流量的来源和搜索的关键词</li></ul><p>像CNZZ、百度统计等可以通过Referer统计访问流量的来源和搜索的关键词（包含在URL中）等等，方便站长们有针性对的进行推广和SEO。</p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><blockquote><p>nginx配置防盗链</p></blockquote><p>利用valid_referers指令防盗链，HTTPReferer头信息是可以通过程序来伪装生成的，所以通过Referer信息防盗链并非100%可靠，但是，它能够限制大部分的盗链。</p><p><code>valid_referers  [none|blocked|server_names]</code><br>默认值：none 使用环境：server，location 该指令会根据Referer Header头的内容分配一个值为0或1给变量$invalid_referer。</p><p>该指令的参数的值：</p><ul><li>none：表示无Referer值</li><li>blocked：表示Referer值被防火墙进行伪装</li><li>server_names：表示一个或者多个主机名称</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~*\.(gif|jpg|png)$ &#123;</span><br><span class="line">    root /home/www/spider/;</span><br><span class="line">    valid_referers *.juphy.cn;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        rewrite ^/soso.com // 当没有referer进行访问时，会自动跳转到这个链接。</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于nginx.conf的配置，if判断注意保持空格。</p><h2 id="反盗链"><a href="#反盗链" class="headerlink" title="反盗链"></a>反盗链</h2><ul><li>通过nodejs设置referer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let option = &#123;</span><br><span class="line">    hostname: &apos;img.juphy.cn&apos;,</span><br><span class="line">    path: &apos;/mono/images/2018-8-22.jpg&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">http.get(option, res =&gt; &#123;</span><br><span class="line">    let imgdata = &apos;&apos;;</span><br><span class="line">    res.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">        imgdata += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        console.log(imgdata);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Referer&quot;&gt;&lt;a href=&quot;#什么是Referer&quot; class=&quot;headerlink&quot; title=&quot;什么是Referer?&quot;&gt;&lt;/a&gt;什么是Referer?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Referer[sic] 请求头字段允许由客户
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.juphy.cn/categories/linux/"/>
    
    
      <category term="referer" scheme="http://blog.juphy.cn/tags/referer/"/>
    
  </entry>
  
  <entry>
    <title>nodejs发起http请求</title>
    <link href="http://blog.juphy.cn/blogs/9b757592.html"/>
    <id>http://blog.juphy.cn/blogs/9b757592.html</id>
    <published>2018-08-23T03:22:00.000Z</published>
    <updated>2018-08-30T09:45:56.172Z</updated>
    
    <content type="html"><![CDATA[<p>【原文】<a href="https://www.twilio.com/blog/2017/08/http-requests-in-node-js.html" target="_blank" rel="noopener">5 Ways to Make HTTP Requests in Node.js</a></p><h2 id="HTTP模块，http或者https库-需要解析JSON格式"><a href="#HTTP模块，http或者https库-需要解析JSON格式" class="headerlink" title="HTTP模块，http或者https库 需要解析JSON格式"></a>HTTP模块，http或者https库 需要解析JSON格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;);</span><br><span class="line">https.get(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&apos;, res =&gt; &#123;</span><br><span class="line">    let data = &apos;&apos;;</span><br><span class="line">    res.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        console.log(1, JSON.parse(data))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">    console.log(&apos;Error：&apos; + err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="request库，如果使用promise可以调用request-promise库"><a href="#request库，如果使用promise可以调用request-promise库" class="headerlink" title="request库，如果使用promise可以调用request-promise库"></a>request库，如果使用promise可以调用request-promise库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line">request(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&apos;, &#123;json: true&#125;, (err, res, body) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        return console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(2, body);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="request-promise库-request的promise操作"><a href="#request-promise库-request的promise操作" class="headerlink" title="request-promise库 request的promise操作"></a>request-promise库 request的promise操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const requestPromise = require(&apos;request-promise&apos;);</span><br><span class="line">requestPromise(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&apos;)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        console.log(3, res);</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Axios是一个基于promise的HTTP客户端，可以用于浏览器和Node.js</p><h3 id="axios库-默认情况下，Axios可以解析JSON响应"><a href="#axios库-默认情况下，Axios可以解析JSON响应" class="headerlink" title="axios库 默认情况下，Axios可以解析JSON响应"></a>axios库 默认情况下，Axios可以解析JSON响应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;);</span><br><span class="line">axios.get(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&apos;)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        console.log(4, res.data);</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios库的all，发起并发请求"><a href="#axios库的all，发起并发请求" class="headerlink" title="axios库的all，发起并发请求"></a>axios库的all，发起并发请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">    axios.get(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&amp;date=2017-08-03&apos;),</span><br><span class="line">    axios.get(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&amp;date=2017-08-02&apos;),</span><br><span class="line">]).then(axios.spread((res1, res2) =&gt; &#123;</span><br><span class="line">    console.log(&apos;res1&apos;, res1.data);</span><br><span class="line">    console.log(&apos;res2&apos;, res2.data);</span><br><span class="line">&#125;)).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="superAgent-默认解析JSON响应，能进行链式调用"><a href="#superAgent-默认解析JSON响应，能进行链式调用" class="headerlink" title="superAgent 默认解析JSON响应，能进行链式调用"></a>superAgent 默认解析JSON响应，能进行链式调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const superagent = require(&apos;superagent&apos;);</span><br><span class="line">superagent.get(&apos;https://api.nasa.gov/planetary/apod&apos;)</span><br><span class="line">    .query(&#123;api_key: &apos;DEMO_KEY&apos;, date: &apos;2017-08-02&apos;&#125;)</span><br><span class="line">    .end((err, res) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return console.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(5, res.body);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="Got-类似于promise，比较轻量，不像request那样臃肿"><a href="#Got-类似于promise，比较轻量，不像request那样臃肿" class="headerlink" title="Got 类似于promise，比较轻量，不像request那样臃肿"></a>Got 类似于promise，比较轻量，不像request那样臃肿</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const got = require(&apos;got&apos;);</span><br><span class="line">got(&apos;https://api.nasa.gov/planetary/apod?api_key=DEMO_KEY&apos;, &#123;json: true&#125;)</span><br><span class="line">    .then(res =&gt; &#123;</span><br><span class="line">        console.log(res.body);</span><br><span class="line">    &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err.reponse.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="node-fetch库与window-fetch-API保持一致"><a href="#node-fetch库与window-fetch-API保持一致" class="headerlink" title="node-fetch库与window.fetch API保持一致"></a>node-fetch库与window.fetch API保持一致</h2><pre><code>const fetch = require(&apos;node-fetch&apos;);// plain text or htmlfetch(&apos;https://github.com/&apos;)    .then(res =&gt; res.text())    .then(body =&gt; console.log(body));// jsonfetch(&apos;https://api.github.com/users/github&apos;)    .then(res =&gt; res.json())    .then(json =&gt; console.log(json));// catch network errorfetch(&apos;http://domain.invalid/&apos;)    .catch(err =&gt; console.error(err));// streamfetch(&apos;https://assets-cdn.github.com/images/modules/logos_page/Octocat.png&apos;)    .then(res =&gt; {        return new Promise((resolve, reject) =&gt; {            const dest = fs.createWriteStream(&apos;./octocat.png&apos;);            res.body.pipe(dest);            res.body.on(&apos;error&apos;, err =&gt; {                reject(err);            });            dest.on(&apos;finish&apos;, () =&gt; {                resolve();            });            dest.on(&apos;error&apos;, err =&gt; {                reject(err);            });        });    });</code></pre><p><a href="https://www.npmjs.com/package/node-fetch" target="_blank" rel="noopener">更多fetch的用法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【原文】&lt;a href=&quot;https://www.twilio.com/blog/2017/08/http-requests-in-node-js.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5 Ways to Make HTTP Reques
      
    
    </summary>
    
      <category term="node" scheme="http://blog.juphy.cn/categories/node/"/>
    
    
      <category term="fetch" scheme="http://blog.juphy.cn/tags/fetch/"/>
    
      <category term="http" scheme="http://blog.juphy.cn/tags/http/"/>
    
      <category term="request" scheme="http://blog.juphy.cn/tags/request/"/>
    
      <category term="axios" scheme="http://blog.juphy.cn/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>nodejs控制异步并发</title>
    <link href="http://blog.juphy.cn/blogs/445785db.html"/>
    <id>http://blog.juphy.cn/blogs/445785db.html</id>
    <published>2018-08-20T07:26:00.000Z</published>
    <updated>2018-08-30T09:45:56.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eventproxy-控制并发"><a href="#eventproxy-控制并发" class="headerlink" title="eventproxy 控制并发"></a>eventproxy 控制并发</h2><p>如果并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。\<br>先定义一个 var count = 0，然后每次抓取成功以后，就 count++。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 count === 3。当值为真时，使用另一个函数继续完成操作。\<br>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来\</p><h3 id="无限嵌套"><a href="#无限嵌套" class="headerlink" title="无限嵌套"></a>无限嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.get(&quot;http://data1_source&quot;, function (data1) &#123;</span><br><span class="line">  // something</span><br><span class="line">  $.get(&quot;http://data2_source&quot;, function (data2) &#123;</span><br><span class="line">    // something</span><br><span class="line">    $.get(&quot;http://data3_source&quot;, function (data3) &#123;</span><br><span class="line">      // something</span><br><span class="line">      var html = fuck(data1, data2, data3);</span><br><span class="line">      render(html);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    var result = &#123;&#125;;</span><br><span class="line">    $.get(&apos;http://data1_source&apos;, data =&gt; &#123;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;);</span><br><span class="line">    $.get(&apos;http://data2_source&apos;, data =&gt; &#123;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;);</span><br><span class="line">    $.get(&apos;http://data3_source&apos;, data =&gt; &#123;</span><br><span class="line">        count++;</span><br><span class="line">        handle();</span><br><span class="line">    &#125;);</span><br><span class="line">    function handle()&#123;</span><br><span class="line">        if(count === 3)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="eventproxy"><a href="#eventproxy" class="headerlink" title="eventproxy"></a>eventproxy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var ep = new eventproxy();</span><br><span class="line"></span><br><span class="line">// ep.all 监听三个事件，每当一个源的数据抓取完成时，就通过ep.emit()来告诉ep，某某事件完成了。当三个事件未同时完成时，ep.emit()调用之后不会做任何事，当三个事件都完成时，就会调用末尾的那个回调函数。</span><br><span class="line">ep.all(&apos;data1_event&apos;, &apos;data2_event&apos;, &apos;data3_event&apos;, function (data1, data2, data3) &#123;</span><br><span class="line">  var html = fuck(data1, data2, data3);</span><br><span class="line">  render(html);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(&apos;http://data1_source&apos;, function (data) &#123;</span><br><span class="line">  ep.emit(&apos;data1_event&apos;, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(&apos;http://data2_source&apos;, function (data) &#123;</span><br><span class="line">  ep.emit(&apos;data2_event&apos;, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">$.get(&apos;http://data3_source&apos;, function (data) &#123;</span><br><span class="line">  ep.emit(&apos;data3_event&apos;, data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>如果已经确定请求的次数，可以使用eventproxy的<code>after</code>API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let eventproxy = require(&apos;eventproxy&apos;);</span><br><span class="line">var ep = new eventproxy();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 命令 ep 重复监听 datas.length 次（在这里也就是 40 次） `data_event` 事件再行动</span><br><span class="line">ep.after(&apos;data_event&apos;, datas.length, function (data) &#123;</span><br><span class="line">  // data 是个数组，包含了 40 次 ep.emit(&apos;data_event&apos;, pair) 中的那 40 个 pair</span><br><span class="line">&#125;</span><br><span class="line">datas.forEach(item =&gt; &#123;</span><br><span class="line">  superagent.get(item.url)</span><br><span class="line">    .end(function (err, res) &#123;</span><br><span class="line">      ep.emit(&apos;data_event&apos;, res);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="async-控制并发"><a href="#async-控制并发" class="headerlink" title="async 控制并发"></a>async 控制并发</h2><p>爬虫时如果太多的并发链接，就会被看做是恶意请求，因此要控制一下并发的数量，如果有1000个链接，并发10个。\</p><h3 id="mapLimit"><a href="#mapLimit" class="headerlink" title="mapLimit"></a>mapLimit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let async = require(&apos;async&apos;);</span><br><span class="line">let count = 0; // 并发的计数器</span><br><span class="line">let fetchUrl = (url, callback) =&gt; &#123;</span><br><span class="line">    let delay = parseInt((Math.random() * 10000000) % 2000, 10);</span><br><span class="line">    count++;</span><br><span class="line">    console.log(&apos;现在并发数是&apos;, count, &apos;，正在抓取的是&apos;, url, &apos;，耗时&apos; + delay + &apos;毫秒&apos;);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        count--;</span><br><span class="line">        callback(null, url + &apos; html content&apos;);</span><br><span class="line">        // 注意callback会将返回结果放在一个数组里</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var urls = [];</span><br><span class="line">for (var i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">    urls.push(&apos;http://datasource_&apos; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async.mapLimit(urls, 5, (url, callback) =&gt; &#123;</span><br><span class="line">    fetchUrl(url, callback);</span><br><span class="line">&#125;, (err, result) =&gt; &#123;</span><br><span class="line">   console.log(&apos;final:&apos;);</span><br><span class="line">   console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a><a href="https://github.com/caolan/async#queueworker-concurrency" target="_blank" rel="noopener">queue</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;eventproxy-控制并发&quot;&gt;&lt;a href=&quot;#eventproxy-控制并发&quot; class=&quot;headerlink&quot; title=&quot;eventproxy 控制并发&quot;&gt;&lt;/a&gt;eventproxy 控制并发&lt;/h2&gt;&lt;p&gt;如果并发异步获取两三个地址的数据，并
      
    
    </summary>
    
      <category term="node" scheme="http://blog.juphy.cn/categories/node/"/>
    
    
      <category term="eventproxy" scheme="http://blog.juphy.cn/tags/eventproxy/"/>
    
      <category term="async" scheme="http://blog.juphy.cn/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>nodejs获取请求参数的方式</title>
    <link href="http://blog.juphy.cn/blogs/b211c1a4.html"/>
    <id>http://blog.juphy.cn/blogs/b211c1a4.html</id>
    <published>2018-08-14T03:22:00.000Z</published>
    <updated>2018-08-30T09:45:56.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs接收get请求参数"><a href="#nodejs接收get请求参数" class="headerlink" title="nodejs接收get请求参数"></a>nodejs接收get请求参数</h2><p>在http协议中，一个完整的url路径如下：</p><p><img src="http://ww1.sinaimg.cn/large/8b2b1aafly1fu91lq2nqaj20se0ebq3a.jpg" alt="完整的url路径"></p><p>get请求的参数是直接在url路径中显示的，在path资源路径的后面添加，以？表示参数的开始，以key = value表示参数的键值对，多个参数以&amp;符号分割，hash表示的是资源定位符，由浏览器自己解析处理。</p><p>浏览器向服务端发送get请求主要有两种方式，一种是href跳转，url拼接参数；一种是ajax请求发送参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let app = http.createServer();</span><br><span class="line">app.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line"></span><br><span class="line">    //1.默认情况下，如果url路径中有中文，则会对中文进行URI编码，所以服务端要想获取中文需要对url进行URI解码</span><br><span class="line">    console.log(encodeURI(req.url));</span><br><span class="line">    // 2.url.parse 方法可以将一个 URL 路径解析为一个方便操作的对象</span><br><span class="line">    // 将第二个可选参数指定为 true， 表示将结果中的 query 解析为一个对象</span><br><span class="line">    var parseObj = url.parse(req.url, true);</span><br><span class="line">    console.log(parseObj);</span><br><span class="line">    var pathname = parseObj.pathname; //相当于无参数的url路径</span><br><span class="line">    console.log(pathname);</span><br><span class="line">    // 这里将解析拿到的查询字符串对象作为一个属性挂载给 req 对象，这样的话在后续的代码中就可以直接通过 req.query 来获取查询字符串了</span><br><span class="line">    req.query = parseObj.query;</span><br><span class="line">    console.log(req.query);</span><br><span class="line">    if (pathname === &apos;/heroAdd&apos;) &#123;</span><br><span class="line">        fs.readFile(&apos;./heroAdd.html&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (pathname.indexOf(&apos;/node_modules&apos;) === 0) &#123;</span><br><span class="line">        fs.readFile(__dirname + pathname, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res.end(&apos;请求路径： &apos; + req.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="nodejs接收post请求参数"><a href="#nodejs接收post请求参数" class="headerlink" title="nodejs接收post请求参数"></a>nodejs接收post请求参数</h2><p>post请求参数不直接在url路径中拼接，而是放在请求体中发送给服务器，请求三要素：请求行、请求头、请求体。</p><p>与get请求不同的是，服务端接收post请求参数不是一次就可以获取的，通常需要多次。</p><h3 id="服务端接收表单数据"><a href="#服务端接收表单数据" class="headerlink" title="服务端接收表单数据"></a>服务端接收表单数据</h3><ul><li>(1)如果表单数据量越多，则发送的次数越多，如果比较少，可能一次就发过来了</li><li>(2)接收表单数据的时候，需要通过监听 req 对象的 data 事件来取数据</li><li>(3)每当收到一段表单提交过来的数据，req 的 data 事件就会被触发一次，同时通过回调函数可以拿到该 段 的数据<br>服务端需要自己添加数据流</li><li>(4)当接收表单提交的数据完毕之后，会执行req的 on 事件</li></ul><h3 id="服务端处理表单数据"><a href="#服务端处理表单数据" class="headerlink" title="服务端处理表单数据"></a>服务端处理表单数据</h3><ul><li>(1) 对数据进行解码（中文数据提交会进行url编码）decodeURI(data)</li><li>(2) 使用querystring对url进行反序列化（解析url将&amp;和=拆分成键值对），得到一个对象。</li><li>(3) 将数据插入到数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//1.导入http模块</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">//导入文件模块</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">//导入路径模块</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">//导入querystring模块（解析post请求数据）</span><br><span class="line">var querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">//2.创建服务器</span><br><span class="line">var app = http.createServer();</span><br><span class="line"></span><br><span class="line">//3.添加响应事件</span><br><span class="line">app.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line"></span><br><span class="line">    console.log(req.method);</span><br><span class="line"></span><br><span class="line">    //1.通过判断url路径和请求方式来判断是否是表单提交</span><br><span class="line">    if (req.url === &apos;/heroAdd&apos; &amp;&amp; req.method === &apos;POST&apos;) &#123;</span><br><span class="line">        /**服务端接收post请求参数的流程</span><br><span class="line">         * （1）给req请求注册接收数据data事件（该方法会执行多次，需要我们手动累加二进制数据）</span><br><span class="line">         *      * 如果表单数据量越多，则发送的次数越多，如果比较少，可能一次就发过来了</span><br><span class="line">         *      * 所以接收表单数据的时候，需要通过监听 req 对象的 data 事件来取数据</span><br><span class="line">         *      * 也就是说，每当收到一段表单提交过来的数据，req 的 data 事件就会被触发一次，同时通过回调函数可以拿到该 段 的数据</span><br><span class="line">         * （2）给req请求注册完成接收数据end事件（所有数据接收完成会执行一次该方法）</span><br><span class="line">         */</span><br><span class="line">        //创建空字符叠加数据片段</span><br><span class="line">        var data = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        //2.注册data事件接收数据（每当收到一段表单提交的数据，该方法会执行一次）</span><br><span class="line">        req.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">            // chunk 默认是一个二进制数据，和 data 拼接会自动 toString</span><br><span class="line">            data += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 3.当接收表单提交的数据完毕之后，就可以进一步处理了</span><br><span class="line">        //注册end事件，所有数据接收完成会执行一次该方法</span><br><span class="line">        req.on(&apos;end&apos;, function () &#123;</span><br><span class="line"></span><br><span class="line">            //（1）.对url进行解码（url会对中文进行编码）</span><br><span class="line">            data = decodeURI(data);</span><br><span class="line">            console.log(data);</span><br><span class="line"></span><br><span class="line">            /**post请求参数不能使用url模块解析，因为他不是一个url，而是一个请求体对象 */</span><br><span class="line"></span><br><span class="line">            //（2）.使用querystring对url进行反序列化（解析url将&amp;和=拆分成键值对），得到一个对象</span><br><span class="line">            //querystring是nodejs内置的一个专用于处理url的模块，API只有四个，详情见nodejs官方文档</span><br><span class="line">            var dataObject = querystring.parse(data);</span><br><span class="line">            console.log(dataObject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (req.url === &apos;/heroAdd&apos; &amp;&amp; req.method === &apos;POST&apos;) &#123;</span><br><span class="line">        fs.readFile(&apos;./heroAdd.html&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else if (req.url.indexOf(&apos;/node_modules&apos;) === 0) &#123;</span><br><span class="line">        fs.readFile(__dirname + req.url, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res.end(&apos;请求路径： &apos; + req.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.监听端口号</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="nodejs使用express框架获取参数的方式"><a href="#nodejs使用express框架获取参数的方式" class="headerlink" title="nodejs使用express框架获取参数的方式"></a>nodejs使用express框架获取参数的方式</h2><h3 id="req-params"><a href="#req-params" class="headerlink" title="req.params"></a>req.params</h3><p>命名过的参数会以键值对的形式存放，路由<code>/user/:name</code>，浏览器访问<code>/user/a</code>，a值即name的属性会存放在req.params.name；如果有多个参数<code>/find/:group/:name</code>，浏览器访问<code>find/a/b</code>，<code>a=req.params.group</code>和<code>b=req.params.name</code>分别获取group和name的两个参数。</p><h3 id="req-query"><a href="#req-query" class="headerlink" title="req.query"></a>req.query</h3><p><code>/user/?id=1</code>，req.query.id会得到1，如果有两个或者两个以上的参数用&amp;连接，<code>/user/?id=1&amp;name=test</code>，req.query.id –&gt; 1，req.query.name –&gt; test。</p><h3 id="req-body"><a href="#req-body" class="headerlink" title="req.body"></a>req.body</h3><p>通过post方式提交的参数<code>$.post(&#39;/add&#39;, {sid: &#39;sid&#39;})</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let bodyParser = require(&apos;body-parser&apos;)</span><br><span class="line">let multer = require(&apos;multer&apos;);</span><br><span class="line">let upload = require(&apos;multer&apos;); // for parsing multipart/form-data</span><br><span class="line">app.use(bodyParser.urlencode(&#123;extended: true&#125;)) // for parsing application/x-www-form-urlencoded</span><br><span class="line">app.use(bodyParser.json()) //  for parsing application/json</span><br><span class="line">app.post(&apos;/add&apos;, function(req, res)&#123;</span><br><span class="line">    let sid = req.body.sid;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(&apos;/profile&apos;, upload.array(), function (req, res, next) &#123;</span><br><span class="line">  console.log(req.body);</span><br><span class="line">  res.json(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="req-param"><a href="#req-param" class="headerlink" title="req.param"></a>req.param</h3><p>req.param()是req.query、req.body、以及req.params获取参数的三种方式的封装，req.params(name)返回name参数的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// POST name=tobi</span><br><span class="line">app.post(&apos;/user?name=tobi&apos;,function(req,res)&#123;</span><br><span class="line"> req.param(&apos;name&apos;);</span><br><span class="line"> // =&gt; &quot;tobi&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// ?name=tobi</span><br><span class="line">req.param(&apos;name&apos;)</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br><span class="line"></span><br><span class="line">// /user/tobi for /user/:name</span><br><span class="line">req.param(&apos;name&apos;)</span><br><span class="line">// =&gt; &quot;tobi&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs接收get请求参数&quot;&gt;&lt;a href=&quot;#nodejs接收get请求参数&quot; class=&quot;headerlink&quot; title=&quot;nodejs接收get请求参数&quot;&gt;&lt;/a&gt;nodejs接收get请求参数&lt;/h2&gt;&lt;p&gt;在http协议中，一个完整的url路
      
    
    </summary>
    
      <category term="node" scheme="http://blog.juphy.cn/categories/node/"/>
    
    
      <category term="express" scheme="http://blog.juphy.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Angular组件通信</title>
    <link href="http://blog.juphy.cn/blogs/ba600921.html"/>
    <id>http://blog.juphy.cn/blogs/ba600921.html</id>
    <published>2018-06-20T06:56:00.000Z</published>
    <updated>2018-08-30T09:45:56.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入属性（父组件-gt-子组件）"><a href="#输入属性（父组件-gt-子组件）" class="headerlink" title="输入属性（父组件-&gt;子组件）"></a>输入属性（父组件-&gt;子组件）</h2><blockquote><p>@Input，自定义属性</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输出属性（子组件-gt-父组件）"><a href="#输出属性（子组件-gt-父组件）" class="headerlink" title="输出属性（子组件-&gt;父组件）"></a>输出属性（子组件-&gt;父组件）</h2><blockquote><p>@Output()，自定义事件</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;p&gt;&#123;&#123;changeMsg&#125;&#125;&lt;/p&gt;</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;</span><br><span class="line">    (change)=&quot;countChange($event)&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line"></span><br><span class="line">  changeMsg: string;</span><br><span class="line"></span><br><span class="line">  countChange(event: number) &#123;</span><br><span class="line">    this.changeMsg = `子组件change事件已触发，当前值是: $&#123;event&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义事件change，接收发送过来的数据。</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input, Output, EventEmitter &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当值改变时，通过事件发射数据接收。</span><br></pre></td></tr></table></figure></p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><blockquote><p>[()]，Angular的双向绑定</p></blockquote><p><em>通过修改绑定属性的方式，使用双向绑定即可，此时在子组件中只需要接收数据。</em></p><h2 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h2><blockquote><p>通过子组件标签的#name,则name就相当于子组件component。</p></blockquote><p>parent.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;ChildComponent&#125; from &apos;./child-component.ts&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;parent-component&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;child-component #child&gt;&lt;/child-component&gt;</span><br><span class="line">    &lt;button (click)=&quot;child.name = childName&quot;&gt;设置子组件名称&lt;/button&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ParentComponent implements OnInit &#123;</span><br><span class="line"></span><br><span class="line">  private childName: string;</span><br><span class="line"></span><br><span class="line">  constructor() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    this.childName = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;child-component&apos;,</span><br><span class="line">  template: `I&apos;m &#123;&#123; name &#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="在查询参数中传递参数"><a href="#在查询参数中传递参数" class="headerlink" title="在查询参数中传递参数"></a>在查询参数中传递参数</h3><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/cinema-chain/cinema&apos;]&quot; [queryParams]=&quot;&#123;chain: 1&#125;&quot;&gt;查看影院&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>点击跳转时，/cinema-chain/cinema?chain=1（?chain=1就是从路由里面传递过来的参数）。</p><p>接收参数的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.queryParams[&apos;chain&apos;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="在url路由路径中传递参数"><a href="#在url路由路径中传递参数" class="headerlink" title="在url路由路径中传递参数"></a>在url路由路径中传递参数</h3><p>在path中传递参数就需要先修改原有的路径使其可以携带参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const routes: Routes = [</span><br><span class="line">  &#123;path: &apos;main/:type&apos;, loadChildren: &apos;./index/index.module#IndexModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;upload&apos;, loadChildren: &apos;./components/upload/upload.module#UploadModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;operation&apos;, loadChildren: &apos;./components/operation/operation.module#OperationModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;compare/:type&apos;, loadChildren: &apos;./components/compare/compare.module#CompareModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;**&apos;, component: PageNotFoundComponent&#125;,</span><br><span class="line">];</span><br><span class="line">整个路径被划分成两段变量</span><br></pre></td></tr></table></figure></p><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line">这里的routerLink是一个数组，第一个值为路由的跳转路径，第二值为路由携带参数的值，这里传递的值为2</span><br><span class="line"></span><br><span class="line">或者这样传递</span><br><span class="line"> constructor(private router: Router) &#123;</span><br><span class="line">    this.router.navigate([&apos;/product&apos;,1]);</span><br><span class="line">    this.router.navigateByUrl(&apos;/product/1&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">或者这样传递</span><br><span class="line">&lt;a routerLink=&quot;/home/&#123;&#123;变量名&#125;&#125;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>页面跳转的结果：/home/2</p><p>接收参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.params[&apos;id&apos;];</span><br><span class="line">   或者 chain = this.activatedRoute.snapshot.paramMap.get(&apos;id&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><em>不能同时使用参数查询方式和路由路径Url 方式传递同一个页面的参数，否则报错。</em></p><h3 id="参数快照和参数订阅"><a href="#参数快照和参数订阅" class="headerlink" title="参数快照和参数订阅"></a>参数快照和参数订阅</h3><p>参数快照：获取路由中传递的参数的值得一个方法就用到了参数快照snapshot。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">change_id()&#123;</span><br><span class="line">  this.router.navigate([&apos;/home&apos;,1]);</span><br><span class="line">&#125;</span><br><span class="line">路由路径中想home同时传递了两个参数，1和2</span><br></pre></td></tr></table></figure></p><p>当在页面第一次加载的时候会创建一次home，将2这个值传入页面，当点击按钮出发change_id事件的时候也会导航到home，但是在此之前主页已经被创建，并已经被赋值，此时导航到主页，主页并不会再次被创建，所以自然不会再次获取第二次导航过来的路由所携带的参数和值，但是路径变为了/home/1。</p><p>然而页面上的值仍然是2，获取当前路由所传递的参数值失败。这就是参数快照的弱点，为了解决这个问题引入了参数订阅：subscribe()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   this.activatedRoute.params.subscribe(params =&gt; &#123;</span><br><span class="line">       const id = params[&apos;id&apos;];</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>采用参数订阅的方式subscribe()获取到一个类型为Params的属性params，并返回params里面的Id复制给本地变量homeID，这样就不会出现路径在变，但是页面里面的参数值不变的情况；</p><h2 id="ViewChild-装饰器"><a href="#ViewChild-装饰器" class="headerlink" title="@ViewChild 装饰器"></a>@ViewChild 装饰器</h2><blockquote><p>父组件获取子组件数据需要借助@ViewChild(),子组件直接引用。</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, ViewChild, AfterViewInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ChildComponent &#125; from &apos;./child.component&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h4&gt;Welcome to Angular World&lt;/h4&gt;</span><br><span class="line">    &lt;exe-child&gt;&lt;/exe-child&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  title: number = 123;</span><br><span class="line">  @ViewChild(ChildComponent)</span><br><span class="line">  childCmp: ChildComponent;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    this.childCmp.name = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-child&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;Child Component&lt;/p&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">    name: string = &apos;&apos;;</span><br><span class="line">    constructor(private appcomponent:AppComponent) &#123;</span><br><span class="line">        this.appcomponent.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基于RxJS-Subject"><a href="#基于RxJS-Subject" class="headerlink" title="基于RxJS Subject"></a>基于RxJS Subject</h2><p><code>rxjs版本基于6需要结合rxjs-compat使用</code><br>message.service.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;of&#125; from &apos;rxjs/observable/of&apos;;</span><br><span class="line">import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class MessageService &#123;</span><br><span class="line">  private subject = new Subject&lt;any&gt;();</span><br><span class="line">  message: any;</span><br><span class="line"></span><br><span class="line">  sendMessage(message: any) &#123;</span><br><span class="line">    this.message = message;</span><br><span class="line">    this.subject.next(message);</span><br><span class="line">    this.subject.complete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearMessage() &#123;</span><br><span class="line">    this.message = null;</span><br><span class="line">    this.subject.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessage(): Observable&lt;any&gt; &#123;</span><br><span class="line">    // return this.subject.asObservable(); // 数据一直在维持，会产生变化</span><br><span class="line">    return of(this.message); // 数据值传递一次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>home.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-home&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Home&lt;/h1&gt;</span><br><span class="line">        &lt;button (click)=&quot;sendMessage()&quot;&gt;Send Message&lt;/button&gt;</span><br><span class="line">        &lt;button (click)=&quot;clearMessage()&quot;&gt;Clear Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HomeComponent &#123;</span><br><span class="line">    constructor(private messageService: MessageService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    sendMessage(): void &#123;</span><br><span class="line">        this.messageService.sendMessage(&apos;Message from Home Component to App Component!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearMessage(): void &#123;</span><br><span class="line">        this.messageService.clearMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnDestroy &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Subscription &#125; from &apos;rxjs/Subscription&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;my-app&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div *ngIf=&quot;message&quot;&gt;&#123;&#123;message.text&#125;&#125;&lt;/div&gt;</span><br><span class="line">       &lt;exe-home&gt;&lt;/exe-home&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppComponent implements OnDestroy &#123;</span><br><span class="line">    message: any;</span><br><span class="line">    subscription: Subscription;</span><br><span class="line"></span><br><span class="line">    constructor(private messageService: MessageService) &#123;</span><br><span class="line">        this.subscription = this.messageService.getMessage().subscribe( message =&gt; &#123;</span><br><span class="line">                                      this.message = message;</span><br><span class="line">                                 &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnDestroy() &#123;</span><br><span class="line">        this.subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>更多<a href="https://github.com/RxJS-CN" target="_blank" rel="noopener">RxJS知识以及用法</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入属性（父组件-gt-子组件）&quot;&gt;&lt;a href=&quot;#输入属性（父组件-gt-子组件）&quot; class=&quot;headerlink&quot; title=&quot;输入属性（父组件-&amp;gt;子组件）&quot;&gt;&lt;/a&gt;输入属性（父组件-&amp;gt;子组件）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由缓存</title>
    <link href="http://blog.juphy.cn/blogs/accf6790.html"/>
    <id>http://blog.juphy.cn/blogs/accf6790.html</id>
    <published>2018-06-13T06:56:00.000Z</published>
    <updated>2018-08-30T09:45:56.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular路由缓存"><a href="#angular路由缓存" class="headerlink" title="angular路由缓存"></a>angular路由缓存</h2><p>路由缓存，input输入状态， 下拉框选中状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#123;RouteReuseStrategy, DefaultUrlSerializer, ActivatedRouteSnapshot, DetachedRouteHandle&#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export class CustomReuseStrategy implements RouteReuseStrategy &#123;</span><br><span class="line"></span><br><span class="line">  public handlers: &#123; [key: string]: DetachedRouteHandle &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  表示对路由允许复用</span><br><span class="line">  shouldDetach(route: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    默认对所有路由复用 可通过给路由配置项增加data: &#123; keep: true &#125;来进行选择性使用，代码如下</span><br><span class="line">    如果是懒加载路由需要在生命组件的位置进行配置</span><br><span class="line">    if (!route.data.keep) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  当路由离开时会触发。按path作为key存储路由快照&amp;组件当前实例对象</span><br><span class="line">  store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void &#123;</span><br><span class="line">    this.handlers[route.routeConfig.path] = handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  若path在缓存中有的都认为允许还原路由</span><br><span class="line">  shouldAttach(route: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    return !!route.routeConfig &amp;&amp; !!this.handlers[route.routeConfig.path];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  从缓存中获取快照，若无则返回null</span><br><span class="line">  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123;</span><br><span class="line">    if (!route.routeConfig) return null;</span><br><span class="line">    if (route.routeConfig.loadChildren) return null; 在loadChildren路径上通过修改自定义RouteReuseStrategy中的检索函数时从不检索分离的路由。</span><br><span class="line">    return this.handlers[route.routeConfig.path];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  进入路由触发，判断是否同一路由</span><br><span class="line">  shouldReuseRoute(future: ActivatedRouteSnapshot, current: ActivatedRouteSnapshot): boolean &#123;</span><br><span class="line">    return future.routeConfig === current.routeConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码引入到app.module.ts文件的providers: [{ provide: RouteReuseStrategy, useClass: AppRoutingCache }]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular路由缓存&quot;&gt;&lt;a href=&quot;#angular路由缓存&quot; class=&quot;headerlink&quot; title=&quot;angular路由缓存&quot;&gt;&lt;/a&gt;angular路由缓存&lt;/h2&gt;&lt;p&gt;路由缓存，input输入状态， 下拉框选中状态&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular的hash模式</title>
    <link href="http://blog.juphy.cn/blogs/36b47415.html"/>
    <id>http://blog.juphy.cn/blogs/36b47415.html</id>
    <published>2018-06-06T06:56:00.000Z</published>
    <updated>2018-08-30T09:45:56.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular开启hash模式"><a href="#angular开启hash模式" class="headerlink" title="angular开启hash模式"></a>angular开启hash模式</h2><p>Hash 模式是基于锚点定位的内部链接机制，在 URL 加上 # ，然后在 # 后面加上 hash 标签，根据不同的标签做定位</p><ul><li>针对初始化时带有路由的项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路由时，routing.module.ts文件中，</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes , &#123; useHash: true &#125;)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>app.module.ts中进行配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入相关服务</span><br><span class="line">import &#123;HashLocationStrategy, LocationStrategy&#125; from &apos;@angular/common&apos;;</span><br><span class="line">// 在@NgModule中的配置如下 | 服务依赖注入</span><br><span class="line">providers: [&#123;provide: LocationStrategy, useClass: HashLocationStrategy&#125;]</span><br></pre></td></tr></table></figure><p><strong> URL 中包含的 hash 信息是不会提交到服务端，所以若要使用 SSR (Server-Side Rendered) ，就不能使用 Hash 模式即不能使用 HashLocationStrategy 策略。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular开启hash模式&quot;&gt;&lt;a href=&quot;#angular开启hash模式&quot; class=&quot;headerlink&quot; title=&quot;angular开启hash模式&quot;&gt;&lt;/a&gt;angular开启hash模式&lt;/h2&gt;&lt;p&gt;Hash 模式是基于锚点定位的内部链
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular如何使用第三方库</title>
    <link href="http://blog.juphy.cn/blogs/332631ae.html"/>
    <id>http://blog.juphy.cn/blogs/332631ae.html</id>
    <published>2018-05-31T06:56:00.000Z</published>
    <updated>2018-08-30T09:45:56.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript模块系统"><a href="#TypeScript模块系统" class="headerlink" title="TypeScript模块系统"></a>TypeScript模块系统</h2><p>模块是指在其自身作用域里执行，而不是在全局作用域里；模块间是依靠 export 和 import 建立关系。编译器在编译过程中，也是依赖这种关系来定位需要编译的文件。</p><p>TypeScript 依然还是以 JavaScript 文件的形式发布类库，这会导致类型无法表述，需要配合<code>声明文件</code>对其进行类型描述；因此<code>声明文件</code>成了类库一个必不可少的组成部分。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="有声明文件"><a href="#有声明文件" class="headerlink" title="有声明文件"></a>有声明文件</h3><p>要分清类库是否有声明文件 *.d.ts</p><blockquote><p>类库自带</p></blockquote><p>从 Npm 安装一个依赖包后，可以直接检查该依赖包库的 package.json 是否包含 typings 节点，该节点对应的文件就是声明文件。</p><blockquote><p>TypeSearch检索</p></blockquote><p>TypeScript 提供了一个叫 <a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeSearch</a> 网站，可以直接输入关键词检查是否包含该类库的声明文件。</p><h3 id="无声明文件"><a href="#无声明文件" class="headerlink" title="无声明文件"></a>无声明文件</h3><p>Angular Cli 创建的项目会包含一个 src/typings.d.ts 声明文件，它会自动包含在全局声明定义中，而把这些类库的声明信息写在这里面再好不过。</p><p>一般而言自己很难对一个类库写一个完整的声明文件，这对于成本来说太不合算，因此往往都是只对部分全局对象做一个 any （表示忽略该静态类型检查）亦可，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare const XLSX: any</span><br></pre></td></tr></table></figure></p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><h3 id="有声明文件-1"><a href="#有声明文件-1" class="headerlink" title="有声明文件"></a>有声明文件</h3><p>对于有声明文件，无需额外做什么，只需在需要模块的地方使用 import 来导入即可。</p><h3 id="无声明文件-1"><a href="#无声明文件-1" class="headerlink" title="无声明文件"></a>无声明文件</h3><p>使用 any 来表示忽略静态类型检查，意味者无法享受声明文件带来的智能提示快感，可以在项目的任意位置直接使用它，但也仅仅只能识别声明的变量，而实例的方法或属性是不可知的。</p><p>除此之外 TypeScript 编译过程中也不会对 G2 做任何类型检查，G2 是否真的存在只能由自己把握。对于 Angular 而言，是需要额外在 angular.json 的 scripts 节点上明确加载这些模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TypeScript模块系统&quot;&gt;&lt;a href=&quot;#TypeScript模块系统&quot; class=&quot;headerlink&quot; title=&quot;TypeScript模块系统&quot;&gt;&lt;/a&gt;TypeScript模块系统&lt;/h2&gt;&lt;p&gt;模块是指在其自身作用域里执行，而不是在全局作
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
      <category term="TypeScript" scheme="http://blog.juphy.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由</title>
    <link href="http://blog.juphy.cn/blogs/527c21d3.html"/>
    <id>http://blog.juphy.cn/blogs/527c21d3.html</id>
    <published>2018-05-24T06:56:00.000Z</published>
    <updated>2018-09-03T07:24:32.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular路由"><a href="#angular路由" class="headerlink" title="angular路由"></a>angular路由</h2><blockquote><p>Base href</p></blockquote><p>index.html中存在<code>&lt;</code>base<code>&gt;</code>标签,路由需要根据这个来确定应用程序的根目录。例如，当我们转到<code>http://example.com/page1</code>时，如果我们没有定义应用程序的基础路径，路由将无法知道我们的应用的托管地址是<code>http://example.com</code>还是<code>http://example.com/page1</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=&quot;/&quot;&gt;</span><br><span class="line">    &lt;title&gt;Application&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;app-root&gt;&lt;/app-root&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>Using the router</p></blockquote><p>要使用路由，我们需要在 AppModule 模块中，导入 RouterModule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;</span><br><span class="line">import &#123; RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; AppComponent &#125; from &apos;./app.component&apos;;</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule</span><br><span class="line">  ],</span><br><span class="line">  bootstrap: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>RouterModule.forRoot()</p></blockquote><p>RouterModule.forRoot() 方法用于在主模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = []; // 便于我们在需要的时候导出ROUTES到其他模块中</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>RouterModule.forChild()</p></blockquote><p>RouterModule.forChild() 与 Router.forRoot() 方法类似，但它只能应用在特性模块中。</p><p><code>根模块中使用 forRoot()，子模块中使用 forChild()。</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CommonModule &#125; from &apos;@angular/common&apos;;</span><br><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    RouterModule.forChild(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Dynamic routes</p></blockquote><p>如果路由始终是静态的，那没有多大的用处。使用动态路由我们可以根据不同的路由参数，渲染不同的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HomeComponent &#125; from &apos;./home/home.component&apos;;</span><br><span class="line">import &#123; ProfileComponent &#125; from &apos;./profile/profile.component&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123; path: &apos;&apos;, component: HomeComponent &#125;,</span><br><span class="line">  &#123; path: &apos;/profile/:username&apos;, component: ProfileComponent &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>/routeUrl/:params</p><p>:params是路由参数，而不是URL的实际部分。</p><p>在访问路由的时候routerLink或者navigate的时候就可以直接传递参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ActivatedRoute &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;profile-page&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;profile&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; username &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsComponent implements OnInit &#123;</span><br><span class="line">  username: string;</span><br><span class="line">  constructor(private route: ActivatedRoute) &#123;&#125;</span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    this.route.params.subscribe((params) =&gt; this.username = params.username);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Child routes</p></blockquote><p>每个路由都支持子路由，在setttings路由中定义了两个子路由，它们将继承父路由的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SettingsComponent &#125; from &apos;./settings/settings.component&apos;;</span><br><span class="line">import &#123; ProfileSettingsComponent &#125; from &apos;./settings/profile/profile.component&apos;;</span><br><span class="line">import &#123; PasswordSettingsComponent &#125; from &apos;./settings/password/password.component&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;settings&apos;,</span><br><span class="line">    component: SettingsComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; path: &apos;profile&apos;, component: ProfileSettingsComponent &#125;,</span><br><span class="line">      &#123; path: &apos;password&apos;, component: PasswordSettingsComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>SettingsComponent组件中需要添加router-outlet指令，因为我们要在设置页面中呈现子路由。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;settings-page&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;settings&quot;&gt;</span><br><span class="line">      &lt;settings-header&gt;&lt;/settings-header&gt;</span><br><span class="line">      &lt;settings-sidebar&gt;&lt;/settings-sidebar&gt;</span><br><span class="line">      &lt;router-outlet&gt;&lt;/router-outlet&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsComponent &#123;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>loadChildren</p></blockquote><p>SettingsModule 模块，用来保存所有 setttings 相关的路由信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NgModule &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; CommonModule &#125; from &apos;@angular/common&apos;;</span><br><span class="line">import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;</span><br><span class="line"></span><br><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;&apos;,</span><br><span class="line">    component: SettingsComponent,</span><br><span class="line">    children: [</span><br><span class="line">      &#123; path: &apos;profile&apos;, component: ProfileSettingsComponent &#125;,</span><br><span class="line">      &#123; path: &apos;password&apos;, component: PasswordSettingsComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    CommonModule,</span><br><span class="line">    RouterModule.forChild(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class SettingsModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在 SettingsModule 模块中我们使用 forChild() 方法，因为 SettingsModule 不是我们应用的主模块。</p><p>另一个主要的区别是我们将 SettingsModule 模块的主路径设置为空路径 (‘’)。因为如果我们路径设置为 /settings ，它将匹配 /settings/settings ，很明显这不是我们想要的结果。通过指定一个空的路径，它就会匹配 /settings 路径，这就是我们想要的结果。</p><p>AppModule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const ROUTES: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;settings&apos;,</span><br><span class="line">    loadChildren: &apos;./settings/settings.module#SettingsModule&apos;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(ROUTES)</span><br><span class="line">  ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>通过 loadChildren 属性，告诉 Angular 路由依据 loadChildren 属性配置的路径去加载 SettingsModule 模块。这就是模块懒加载功能的具体应用，当用户访问 /settings/** 路径的时候，才会加载对应的 SettingsModule 模块，这减少了应用启动时加载资源的大小。</p><ul><li>loadChildren 的属性值，该字符串由三部分组成：<ul><li>需要导入模块的相对路径</li><li><code>#</code>分隔符</li><li>导出模块类的名称</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;angular路由&quot;&gt;&lt;a href=&quot;#angular路由&quot; class=&quot;headerlink&quot; title=&quot;angular路由&quot;&gt;&lt;/a&gt;angular路由&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Base href&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由之history与locationStrategy</title>
    <link href="http://blog.juphy.cn/blogs/a0e83b13.html"/>
    <id>http://blog.juphy.cn/blogs/a0e83b13.html</id>
    <published>2018-05-17T06:56:00.000Z</published>
    <updated>2018-08-30T09:45:56.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>length<br>  只读的，其值为一个整数，标志包括当前页面在内的会话历史中的记录数量，比如我们通常打开一个空白窗口，length 为 0，再访问一个页面，其 length 变为 1。</li><li>scrollRestoration<br>  允许 Web 应用在会话历史导航时显式地设置默认滚动复原，其值为 auto 或 manual。</li><li>state<br>  只读，返回代表会话历史堆栈顶部记录的任意可序列化类型数据值，我们可以以此来区别不同会话历史纪录</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>back()<br>  返回会话历史记录中的上一个页面，等价于 window.history.go(-1) 和点击浏览器的后退按钮。</li><li>forward()<br>  进入会话历史记录中的下一个页面，等价于 window.history.go(1) 和点击浏览器的前进按钮。</li><li>go()<br>  加载会话历史记录中的某一个页面，通过该页面与当前页面在会话历史中的相对位置定位，如，-1 代表当前页面的上一个记录，1 代表当前页面的下一个页面。若不传参数或传入0，则会重新加载当前页面；若参数超出当前会话历史纪录数，则不进行操作。</li><li><p>pushState()<br>  在会话历史堆栈顶部插入一条记录，该方法接收三个参数，一个state 对象，一个页面标题，一个 URL：</p><ul><li><p>状态对象</p><p>  1、存储新添会话历史记录的状态信息对象，每次访问该条会话时，都会触发 popstate 事件，并且事件回调函数会接收一个参数，值为该事件对象的复制副本。</p><p>  2、状态对象可以是任何可序列化的数据，浏览器将状态对象存储在用户的磁盘以便用户再次重启浏览器时能恢复数据</p><p>  3、一个状态对象序列化后的最大长度是 640K，如果传递数据过大，则会抛出异常</p></li><li><p>页面标题</p><p>  目前该参数值会被忽略，暂不被使用，可以传入空字符串</p></li><li><p>页面 URL</p><p>  1、此参数声明新添会话记录的入口 URL</p><p>  2、在调用 pushState() 方法后，浏览器不会加载 URL 指向的页面，我们可以在 popstate 事件回调中处理页面是否加载</p><p>  3、此 URL 必须与当前页面 URL 同源,，否则会抛异常；其值可以是绝对地址，也可以是相对地址，相对地址会被基于当前页面 URL 解析得到绝对地址；若其值为空，则默认是当前页面 URL</p></li></ul></li><li><p>replaceState()</p><ul><li>更新会话历史堆栈顶部记录信息，支持的参数信息与 pushState() 一致。</li><li>pushState() 与 replaceState() 的区别：pushState()是在 history 栈中添加一个新的条目，replaceState() 是替换当前的记录值。此外这两个方法改变的只是浏览器关于当前页面的标题和 URL 的记录情况，并不会刷新或改变页面展示。</li></ul></li><li><p>onpopstate 事件</p><ul><li>window.onpopstate 是 popstate 事件在 window 对象上的事件句柄。每当处于激活状态的历史记录条目发生变化时，popstate 事件就会在对应 window 对象上触发。如果当前处于激活状态的历史记录条目是由 history.pushState() 方法创建，或者由 history.replaceState() 方法修改过的，则 popstate 事件对象的 state 属性包含了这个历史记录条目的 state 对象的一个拷贝。</li><li>调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。popstate 事件只会在浏览器某些行为下触发，比如点击后退、前进按钮 (或者在 JavaScript 中调用 history.back()、history.forward()、history.go() 方法)。</li><li>当网页加载时，各浏览器对 popstate 事件是否触发有不同的表现，Chrome 和 Safari 会触发 popstate 事件，而 Firefox 不会。</li></ul></li></ul><h2 id="Hash模式和Html5模式"><a href="#Hash模式和Html5模式" class="headerlink" title="Hash模式和Html5模式"></a>Hash模式和Html5模式</h2><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p>Hash 模式是基于锚点定位的内部链接机制，在 URL 加上 # ，然后在 # 后面加上 hash 标签，根据不同的标签做定位</p><blockquote><p>针对初始化时带有路由的项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置路由时，routing.module.ts文件中，</span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes , &#123; useHash: true &#125;)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>app.module.ts中进行配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入相关服务</span><br><span class="line">import &#123;HashLocationStrategy, LocationStrategy&#125; from &apos;@angular/common&apos;;</span><br><span class="line">// 在@NgModule中的配置如下 | 服务依赖注入</span><br><span class="line">providers: [&#123;provide: LocationStrategy, useClass: HashLocationStrategy&#125;]</span><br></pre></td></tr></table></figure><p><code>URL 中包含的 hash 信息是不会提交到服务端，所以若要使用 SSR (Server-Side Rendered) ，就不能使用 Hash 模式即不能使用 HashLocationStrategy 策略。</code></p><h3 id="HTML5模式"><a href="#HTML5模式" class="headerlink" title="HTML5模式"></a>HTML5模式</h3><p>HTML 5 模式则直接使用跟”真实”的 URL 一样，如上面的路径，在 HTML 5 模式地址如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/u/angular4/user</span><br></pre></td></tr></table></figure></p><ul><li>HTML5模式下URL有两种访问方式:<ul><li>在浏览器地址栏直接输入 URL，这会向服务器请求加载页面。</li><li>在 Angular 应用程序中，访问 HTML 5 模式下的 URL 地址，这不需要重新加载页面，可以直接切换到对应的视图。</li></ul></li></ul><p>在 HTML 5 模式下，Angular 使用了 HTML 5 的 pushState() API 来动态改变浏览器的 URL 而不用重新刷新页面。</p><blockquote><p>开启HTML5模式</p></blockquote><p>导入 APP_BASE_HREF、LocationStrategy、PathLocationStrategy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; APP_BASE_HREF, LocationStrategy, PathLocationStrategy &#125; from &apos;@angular/common&apos;</span><br></pre></td></tr></table></figure><p>配置NgModule-providers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@NgModule(&#123;</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    RouterModule.forRoot(routes)</span><br><span class="line">  ],</span><br><span class="line">  ..,</span><br><span class="line">  providers: [</span><br><span class="line">    &#123; provide: LocationStrategy, useClass: PathLocationStrategy &#125;,</span><br><span class="line">    &#123; provide: APP_BASE_HREF, useValue: &apos;/&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例代码中的 APP_BASE_HREF，用于设置资源 (图片、脚本、样式) 加载的基础路径。除了在 NgModule 中配置 provider 外，我们也可以在入口文件，如 index.html 文件 &lt;base&gt; 标签中设置基础路径。</p><p>&lt;base&gt; 标签为页面上的所有链接规定默认地址或默认目标。通常情况下，浏览器会从当前文档的 URL 中提取相应的路径来补全相对 URL 中缺失的部分。使用 &lt;base&gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt; 标签中的 URL。具体使用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=&quot;/&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="LocationStrategy"><a href="#LocationStrategy" class="headerlink" title="LocationStrategy"></a>LocationStrategy</h2><p>LocationStrategy 用于从浏览器 URL 中读取路由状态。Angular 中提供两种 LocationStrategy 策略：</p><ul><li><p>HashLocationStrategy</p></li><li><p>PathLocationStrategy</p></li></ul><p>以上两种策略都是继承于 LocationStrategy 抽象类，该类的具体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export abstract class LocationStrategy &#123;</span><br><span class="line">  // 获取path路径</span><br><span class="line">  abstract path(includeHash?: boolean): string;</span><br><span class="line">  // 生成完整的外部链接</span><br><span class="line">  abstract prepareExternalUrl(internal: string): string;</span><br><span class="line">  // 添加会话历史状态</span><br><span class="line">  abstract pushState(state: any, title: string, url: string,</span><br><span class="line">      queryParams: string): void;</span><br><span class="line">  // 修改会话历史状态</span><br><span class="line">  abstract replaceState(state: any, title: string, url: string,</span><br><span class="line">      queryParams: string): void;</span><br><span class="line">  // 进入会话历史记录中的下一个页面</span><br><span class="line">  abstract forward(): void;</span><br><span class="line">  // 返回会话历史记录中的上一个页面</span><br><span class="line">  abstract back(): void;</span><br><span class="line">  // 设置popstate监听</span><br><span class="line">  abstract onPopState(fn: LocationChangeListener): void;</span><br><span class="line">  // 获取base地址信息</span><br><span class="line">  abstract getBaseHref(): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashLocationStrategy"><a href="#HashLocationStrategy" class="headerlink" title="HashLocationStrategy"></a>HashLocationStrategy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashLocationStrategy 类继承于 LocationStrategy 抽象类，它的构造函数如下：</span><br><span class="line"></span><br><span class="line">export class HashLocationStrategy extends LocationStrategy &#123;</span><br><span class="line">  constructor(</span><br><span class="line">      private _platformLocation: PlatformLocation,</span><br><span class="line">      @Optional() @Inject(APP_BASE_HREF) _baseHref?: string) &#123;</span><br><span class="line">      super();</span><br><span class="line">      if (_baseHref != null) &#123;</span><br><span class="line">        this._baseHref = _baseHref;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数依赖 PlatformLocation 及 APP_BASE_HREF 关联的对象。APP_BASE_HREF 的作用，我们上面已经介绍过了，接下来我们来分析一下 PlatformLocation 对象。</p><h3 id="PlatformLocation"><a href="#PlatformLocation" class="headerlink" title="PlatformLocation"></a>PlatformLocation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// angular2/packages/platform-browser/src/browser.ts</span><br><span class="line">export const INTERNAL_BROWSER_PLATFORM_PROVIDERS: Provider[] = [</span><br><span class="line">  ...,</span><br><span class="line">  &#123;provide: PlatformLocation, useClass: BrowserPlatformLocation&#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以知道在浏览器环境中，HashLocationStrategy 构造函数中注入的 PlatformLocation 对象是 BrowserPlatformLocation 类的实例。我们也先来看一下 BrowserPlatformLocation 类的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// angular2/packages/platform-browser/src/browser/location/browser_platform_location.ts</span><br><span class="line">export class BrowserPlatformLocation extends PlatformLocation &#123;</span><br><span class="line">  private _location: Location;</span><br><span class="line">  private _history: History;</span><br><span class="line"></span><br><span class="line">  constructor(@Inject(DOCUMENT) private _doc: any) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this._init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _init() &#123;</span><br><span class="line">    this._location = getDOM().getLocation(); // 获取浏览器平台下Location对象</span><br><span class="line">    this._history = getDOM().getHistory(); // 获取浏览器平台下的History对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 BrowserPlatformLocation 构造函数中，我们调用 _init() 方法，在方法体中，我们调用 getDOM() 方法返回对象中的 getLocation() 和 getHistory() 方法，分别获取 Location 对象和 History 对象。那 getDOM() 方法返回的是什么对象呢？其实该方法返回的是 DomAdapter 对象。</p><h3 id="DomAdapter"><a href="#DomAdapter" class="headerlink" title="DomAdapter"></a>DomAdapter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let _DOM: DomAdapter = null !;</span><br><span class="line"></span><br><span class="line">export function getDOM() &#123;</span><br><span class="line">  return _DOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setDOM(adapter: DomAdapter) &#123;</span><br><span class="line">  _DOM = adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function setRootDomAdapter(adapter: DomAdapter) &#123;</span><br><span class="line">  if (!_DOM) &#123;</span><br><span class="line">    _DOM = adapter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那什么时候会调用 setDOM() 或 setRootDomAdapter() 方法呢？通过查看 Angular 源码，我们发现在浏览器平台初始化时，会调用 setRootDomAdapter() 方法。具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export const INTERNAL_BROWSER_PLATFORM_PROVIDERS: Provider[] = [</span><br><span class="line">  &#123;provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true&#125;,</span><br><span class="line">  ...</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;History-对象&quot;&gt;&lt;a href=&quot;#History-对象&quot; class=&quot;headerlink&quot; title=&quot;History 对象&quot;&gt;&lt;/a&gt;History 对象&lt;/h2&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://blog.juphy.cn/blogs/c793072c.html"/>
    <id>http://blog.juphy.cn/blogs/c793072c.html</id>
    <published>2018-05-10T06:56:00.000Z</published>
    <updated>2018-08-31T05:27:29.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li>特点：<ul><li>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（full-duplex）的通信。</li><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。</li><li>协议标识符是ws（如果加密，则为wss，对应 HTTPS 协议），服务器网址就是 URL。</li></ul></li></ul><h3 id="WebSocket握手"><a href="#WebSocket握手" class="headerlink" title="WebSocket握手"></a>WebSocket握手</h3><ul><li>浏览器发出：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: null</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>HTTP1.1 协议规定，Upgrade表示将通信协议从HTTP/1.1转向该字段指定的协议。Connection字段表示浏览器通知服务器，如果可以的话，就升级到 WebSocket 协议。Origin字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）。Sec-WebSocket-Key则是用于握手协议的密钥，是 Base64 编码的16字节随机字符串。</p><ul><li>服务器响应：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Origin: null</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><p>服务器同样用Connection字段通知浏览器，需要改变协议。Sec-WebSocket-Accept字段是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取 SHA-1 的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 WebSocket 请求。Sec-WebSocket-Location字段表示进行通信的 WebSocket 网址。</p><blockquote><p>完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据。</p></blockquote><h3 id="客服端API"><a href="#客服端API" class="headerlink" title="客服端API"></a>客服端API</h3><ul><li>浏览器对 WebSocket 协议的处理，无非就是三件事。<ul><li>建立连接和断开连接</li><li>发送数据和接收数据</li><li>处理错误</li></ul></li></ul><h4 id="1、-构造WebSocket函数"><a href="#1、-构造WebSocket函数" class="headerlink" title="1、 构造WebSocket函数"></a>1、 构造WebSocket函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&apos;ws://localhost: 8080&apos;);</span><br></pre></td></tr></table></figure><p>执行上面语句之后，客户端就会与服务器进行连接。</p><h4 id="2、webSocket-readyState"><a href="#2、webSocket-readyState" class="headerlink" title="2、webSocket.readyState"></a>2、webSocket.readyState</h4><ul><li>readyState属性返回实例对象的当前状态，共有四种。<ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">switch (ws.readyState) &#123;</span><br><span class="line">  case WebSocket.CONNECTING:</span><br><span class="line">  // case 0:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.OPEN:</span><br><span class="line">  // case 1:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSING:</span><br><span class="line">  // case 2:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSED:</span><br><span class="line">  // case 3:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    // this never happens</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、webSocket的api"><a href="#3、webSocket的api" class="headerlink" title="3、webSocket的api"></a>3、webSocket的api</h4><ul><li>webSocket.onopen 用于指定连接成功后的回调函数</li><li>webSocket.onclose 用于指定连接关闭后的回调函数</li><li>webSocket.onmessage 用于指定收到服务器数据后的回调函数，服务器数据可能是文本，也可能是二进制数据（blob对象或ArrayBuffer）</li><li>webSocket.send() 用于向服务器发送数据</li><li>webSocket.bufferedAmount 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</li><li>webSocket.onerror</li></ul><h2 id="RxJS封装的WebSocket"><a href="#RxJS封装的WebSocket" class="headerlink" title="RxJS封装的WebSocket"></a>RxJS封装的WebSocket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class WebsocketService &#123;</span><br><span class="line">  private ws: WebSocket;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> // 发送数据</span><br><span class="line">  send(message: any) &#123;</span><br><span class="line">    this.ws.send(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> // 建立连接</span><br><span class="line">  connect(url: string): Observable&lt;any&gt; &#123;</span><br><span class="line">    this.ws = new WebSocket(url);</span><br><span class="line">    return new Observable(observer =&gt; &#123;</span><br><span class="line">      this.ws.onmessage = (event) =&gt; observer.next(event.data);</span><br><span class="line">      this.ws.onerror = (event) =&gt; observer.error(event);</span><br><span class="line">      this.ws.onclose = (event) =&gt; &#123;</span><br><span class="line">        console.log(event, &apos;服务器端断开链接！&apos;);</span><br><span class="line">        observer.complete();</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> // 断开连接</span><br><span class="line">  disconnect() &#123;</span><br><span class="line">    this.ws.close();</span><br><span class="line">    console.log(&apos;浏览器端断开链接！&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket&quot;&gt;&lt;a href=&quot;#WebSocket&quot; class=&quot;headerlink&quot; title=&quot;WebSocket&quot;&gt;&lt;/a&gt;WebSocket&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;特点：&lt;ul&gt;
&lt;li&gt;服务器可以主动向客户端推送信息，客户端也可以主动
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.cn/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.cn/tags/Angular/"/>
    
      <category term="WebSocket" scheme="http://blog.juphy.cn/tags/WebSocket/"/>
    
  </entry>
  
</feed>
