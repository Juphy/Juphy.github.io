<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>挽留之王小石</title>
  <icon>https://www.gravatar.com/avatar/a23107e3958da4844989715e80058f71</icon>
  <subtitle>Hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.juphy.com/"/>
  <updated>2018-08-08T07:08:02.586Z</updated>
  <id>http://blog.juphy.com/</id>
  
  <author>
    <name>Juphy</name>
    <email>gaojuphy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular组件通信</title>
    <link href="http://blog.juphy.com/2018/06/20/Angular%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.juphy.com/2018/06/20/Angular组件通信/</id>
    <published>2018-06-20T06:56:00.000Z</published>
    <updated>2018-08-08T07:08:02.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入属性（父组件-gt-子组件）"><a href="#输入属性（父组件-gt-子组件）" class="headerlink" title="输入属性（父组件-&gt;子组件）"></a>输入属性（父组件-&gt;子组件）</h2><blockquote><p>@Input，自定义属性</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输出属性（子组件-gt-父组件）"><a href="#输出属性（子组件-gt-父组件）" class="headerlink" title="输出属性（子组件-&gt;父组件）"></a>输出属性（子组件-&gt;父组件）</h2><blockquote><p>@Output()，自定义事件</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;exe-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">   &lt;p&gt;&#123;&#123;changeMsg&#125;&#125;&lt;/p&gt;</span><br><span class="line">   &lt;exe-counter [count]=&quot;initialCount&quot;</span><br><span class="line">    (change)=&quot;countChange($event)&quot;&gt;&lt;/exe-counter&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  initialCount: number = 5;</span><br><span class="line"></span><br><span class="line">  changeMsg: string;</span><br><span class="line"></span><br><span class="line">  countChange(event: number) &#123;</span><br><span class="line">    this.changeMsg = `子组件change事件已触发，当前值是: $&#123;event&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义事件change，接收发送过来的数据。</span><br></pre></td></tr></table></figure></p><p>counter.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input, Output, EventEmitter &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-counter&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;当前值: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button (click)=&quot;increment()&quot;&gt; + &lt;/button&gt;</span><br><span class="line">      &lt;button (click)=&quot;decrement()&quot;&gt; - &lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line">    @Input() count: number = 0;</span><br><span class="line"></span><br><span class="line">    @Output() change: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">    increment() &#123;</span><br><span class="line">        this.count++;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count--;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 当值改变时，通过事件发射数据接收。</span><br></pre></td></tr></table></figure></p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><blockquote><p>[()]，Angular的双向绑定</p></blockquote><p><em>通过修改绑定属性的方式，使用双向绑定即可，此时在子组件中只需要接收数据。</em></p><h2 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h2><blockquote><p>通过子组件标签的#name,则name就相当于子组件component。</p></blockquote><p>parent.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component, OnInit&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;ChildComponent&#125; from &apos;./child-component.ts&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;parent-component&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;child-component #child&gt;&lt;/child-component&gt;</span><br><span class="line">    &lt;button (click)=&quot;child.name = childName&quot;&gt;设置子组件名称&lt;/button&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ParentComponent implements OnInit &#123;</span><br><span class="line"></span><br><span class="line">  private childName: string;</span><br><span class="line"></span><br><span class="line">  constructor() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    this.childName = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Component&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;child-component&apos;,</span><br><span class="line">  template: `I&apos;m &#123;&#123; name &#125;&#125;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="在查询参数中传递参数"><a href="#在查询参数中传递参数" class="headerlink" title="在查询参数中传递参数"></a>在查询参数中传递参数</h3><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/cinema-chain/cinema&apos;]&quot; [queryParams]=&quot;&#123;chain: 1&#125;&quot;&gt;查看影院&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>点击跳转时，/cinema-chain/cinema?chain=1（?chain=1就是从路由里面传递过来的参数）。</p><p>接收参数的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.queryParams[&apos;chain&apos;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="在url路由路径中传递参数"><a href="#在url路由路径中传递参数" class="headerlink" title="在url路由路径中传递参数"></a>在url路由路径中传递参数</h3><p>在path中传递参数就需要先修改原有的路径使其可以携带参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const routes: Routes = [</span><br><span class="line">  &#123;path: &apos;main/:type&apos;, loadChildren: &apos;./index/index.module#IndexModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;upload&apos;, loadChildren: &apos;./components/upload/upload.module#UploadModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;operation&apos;, loadChildren: &apos;./components/operation/operation.module#OperationModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;compare/:type&apos;, loadChildren: &apos;./components/compare/compare.module#CompareModule&apos;&#125;,</span><br><span class="line">  &#123;path: &apos;**&apos;, component: PageNotFoundComponent&#125;,</span><br><span class="line">];</span><br><span class="line">整个路径被划分成两段变量</span><br></pre></td></tr></table></figure></p><p>传递参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line">这里的routerLink是一个数组，第一个值为路由的跳转路径，第二值为路由携带参数的值，这里传递的值为2</span><br><span class="line"></span><br><span class="line">或者这样传递</span><br><span class="line"> constructor(private router: Router) &#123;</span><br><span class="line">    this.router.navigate([&apos;/product&apos;,1]);</span><br><span class="line">    this.router.navigateByUrl(&apos;/product/1&apos;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>页面跳转的结果：/home/2</p><p>接收参数页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   const chain = this.activatedRoute.snapshot.params[&apos;id&apos;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><em>不能同时使用参数查询方式和路由路径Url 方式传递同一个页面的参数，否则报错。</em></p><h3 id="参数快照和参数订阅"><a href="#参数快照和参数订阅" class="headerlink" title="参数快照和参数订阅"></a>参数快照和参数订阅</h3><p>参数快照：获取路由中传递的参数的值得一个方法就用到了参数快照snapshot。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a [routerLink]=&quot;[&apos;/home&apos;,2]&quot;&gt;主页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">change_id()&#123;</span><br><span class="line">  this.router.navigate([&apos;/home&apos;,1]);</span><br><span class="line">&#125;</span><br><span class="line">路由路径中想home同时传递了两个参数，1和2</span><br></pre></td></tr></table></figure></p><p>当在页面第一次加载的时候会创建一次home，将2这个值传入页面，当点击按钮出发change_id事件的时候也会导航到home，但是在此之前主页已经被创建，并已经被赋值，此时导航到主页，主页并不会再次被创建，所以自然不会再次获取第二次导航过来的路由所携带的参数和值，但是路径变为了/home/1。</p><p>然而页面上的值仍然是2，获取当前路由所传递的参数值失败。这就是参数快照的弱点，为了解决这个问题引入了参数订阅：subscribe()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(private activatedRoute: ActivatedRoute) &#123;</span><br><span class="line">   this.activatedRoute.params.subscribe(params =&gt; &#123;</span><br><span class="line">       const id = params[&apos;id&apos;];</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>采用参数订阅的方式subscribe()获取到一个类型为Params的属性params，并返回params里面的Id复制给本地变量homeID，这样就不会出现路径在变，但是页面里面的参数值不变的情况；</p><h2 id="ViewChild-装饰器"><a href="#ViewChild-装饰器" class="headerlink" title="@ViewChild 装饰器"></a>@ViewChild 装饰器</h2><blockquote><p>父组件获取子组件数据需要借助@ViewChild(),子组件直接引用。</p></blockquote><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, ViewChild, AfterViewInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; ChildComponent &#125; from &apos;./child.component&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h4&gt;Welcome to Angular World&lt;/h4&gt;</span><br><span class="line">    &lt;exe-child&gt;&lt;/exe-child&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent &#123;</span><br><span class="line">  title: number = 123;</span><br><span class="line">  @ViewChild(ChildComponent)</span><br><span class="line">  childCmp: ChildComponent;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    this.childCmp.name = &apos;child-component&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>child.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-child&apos;,</span><br><span class="line">    template: `</span><br><span class="line">      &lt;p&gt;Child Component&lt;/p&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildComponent &#123;</span><br><span class="line">    name: string = &apos;&apos;;</span><br><span class="line">    constructor(private appcomponent:AppComponent) &#123;</span><br><span class="line">        this.appcomponent.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基于RxJS-Subject"><a href="#基于RxJS-Subject" class="headerlink" title="基于RxJS Subject"></a>基于RxJS Subject</h2><p>message.service.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Injectable&#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123;of&#125; from &apos;rxjs/observable/of&apos;;</span><br><span class="line">import &#123;Subject&#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line">import &#123;Observable&#125; from &apos;rxjs/Observable&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class MessageService &#123;</span><br><span class="line">  private subject = new Subject&lt;any&gt;();</span><br><span class="line">  message: any;</span><br><span class="line"></span><br><span class="line">  sendMessage(message: any) &#123;</span><br><span class="line">    this.message = message;</span><br><span class="line">    this.subject.next(message);</span><br><span class="line">    this.subject.complete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearMessage() &#123;</span><br><span class="line">    this.message = null;</span><br><span class="line">    this.subject.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMessage(): Observable&lt;any&gt; &#123;</span><br><span class="line">    // return this.subject.asObservable(); // 数据一直在维持，会产生变化</span><br><span class="line">    return of(this.message); // 数据值传递一次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>home.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-home&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Home&lt;/h1&gt;</span><br><span class="line">        &lt;button (click)=&quot;sendMessage()&quot;&gt;Send Message&lt;/button&gt;</span><br><span class="line">        &lt;button (click)=&quot;clearMessage()&quot;&gt;Clear Message&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class HomeComponent &#123;</span><br><span class="line">    constructor(private messageService: MessageService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    sendMessage(): void &#123;</span><br><span class="line">        this.messageService.sendMessage(&apos;Message from Home Component to App Component!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearMessage(): void &#123;</span><br><span class="line">        this.messageService.clearMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.component.ts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnDestroy &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Subscription &#125; from &apos;rxjs/Subscription&apos;;</span><br><span class="line">import &#123; MessageService &#125; from &apos;./message.service&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;my-app&apos;,</span><br><span class="line">    template: `</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div *ngIf=&quot;message&quot;&gt;&#123;&#123;message.text&#125;&#125;&lt;/div&gt;</span><br><span class="line">       &lt;exe-home&gt;&lt;/exe-home&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export class AppComponent implements OnDestroy &#123;</span><br><span class="line">    message: any;</span><br><span class="line">    subscription: Subscription;</span><br><span class="line"></span><br><span class="line">    constructor(private messageService: MessageService) &#123;</span><br><span class="line">        this.subscription = this.messageService</span><br><span class="line">                                  .getMessage().subscribe( message =&gt; &#123;</span><br><span class="line">                                      this.message = message;</span><br><span class="line">                                 &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnDestroy() &#123;</span><br><span class="line">        this.subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>更多<a href="https://github.com/RxJS-CN" target="_blank" rel="noopener">RxJS知识</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入属性（父组件-gt-子组件）&quot;&gt;&lt;a href=&quot;#输入属性（父组件-gt-子组件）&quot; class=&quot;headerlink&quot; title=&quot;输入属性（父组件-&amp;gt;子组件）&quot;&gt;&lt;/a&gt;输入属性（父组件-&amp;gt;子组件）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Angular" scheme="http://blog.juphy.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>SheetJS</title>
    <link href="http://blog.juphy.com/2018/06/19/SheetJS/"/>
    <id>http://blog.juphy.com/2018/06/19/SheetJS/</id>
    <published>2018-06-18T16:00:00.000Z</published>
    <updated>2018-06-20T02:50:41.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;javascript&quot; src=&quot;xlsx.full.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm instal xlsx</span><br></pre></td></tr></table></figure></li><li><p>老版本浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- add the shim first --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;shim.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- after the shim is referenced, add the library --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;xlsx.full.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Angular-2"><a href="#Angular-2" class="headerlink" title="Angular 2+"></a>Angular 2+</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as XLSX from &apos;xlsx&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>sheet_to_json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* &lt;input type=&quot;file&quot; (change)=&quot;onFileChange($event)&quot; multiple=&quot;false&quot; /&gt; */</span><br><span class="line"></span><br><span class="line">  onFileChange(evt: any) &#123;</span><br><span class="line">    /* wire up file reader */</span><br><span class="line">    const target: DataTransfer = &lt;DataTransfer&gt;(evt.target);</span><br><span class="line">    if (target.files.length !== 1) throw new Error(&apos;Cannot use multiple files&apos;);</span><br><span class="line">    const reader: FileReader = new FileReader();</span><br><span class="line">    reader.onload = (e: any) =&gt; &#123;</span><br><span class="line">      /* read workbook */</span><br><span class="line">      const bstr: string = e.target.result;</span><br><span class="line">      const wb: XLSX.WorkBook = XLSX.read(bstr, &#123;type: &apos;binary&apos;&#125;);</span><br><span class="line"></span><br><span class="line">      /* grab first sheet */</span><br><span class="line">      const wsname: string = wb.SheetNames[0];</span><br><span class="line">      const ws: XLSX.WorkSheet = wb.Sheets[wsname];</span><br><span class="line"></span><br><span class="line">      /* save data */</span><br><span class="line">      this.data = &lt;AOA&gt;(XLSX.utils.sheet_to_json(ws, &#123;header: 1&#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsBinaryString(target.files[0]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>结合Ant Design使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">&lt;nz-upload [nzBeforeUpload]=&quot;beforeUpload&quot;&gt;</span><br><span class="line">   &lt;button nz-button&gt;导入文件&lt;/button&gt;</span><br><span class="line">&lt;/nz-upload&gt;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">reader: FileReader = new FileReader();</span><br><span class="line"></span><br><span class="line">constructor()&#123;</span><br><span class="line">    this.reader.onloadstart=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.reader.onload = (e: any)=&gt;&#123;</span><br><span class="line">        const bstr: string = e.target.result;</span><br><span class="line">        const wb: XLSX.WorkBook = XLSX.read(bstr, &#123;type: &apos;binary&apos;&#125;);</span><br><span class="line">        const sheet = wb.Sheets[wb.SheetNames[0]];</span><br><span class="line">        const json = XLSX.utils.sheet_to_json(sheet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.header.onloadend = () =&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeUpload = (file: UploadFile): boolean =&gt; &#123;</span><br><span class="line">  this.reader.readAsBinaryString(this.file);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>json_to_sheet/aoa_to_sheet</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* generate worksheet */</span><br><span class="line">const ws: XLSX.WorkSheet = XLSX.utils.json_to_sheet(data);</span><br><span class="line">const ws: XLSX.WorkSheet = XLSX.utils.aoa_to_sheet(data);</span><br><span class="line"></span><br><span class="line">/* generate workbook and add the worksheet */</span><br><span class="line">const wb: XLSX.WorkBook = XLSX.utils.book_new();</span><br><span class="line">XLSX.utils.book_append_sheet(wb, ws, &apos;Sheet1&apos;);</span><br><span class="line"></span><br><span class="line">/* save to file */</span><br><span class="line">XLSX.writeFile(wb, &apos;SheetJS.xlsx&apos;);</span><br><span class="line"></span><br><span class="line">或者使用file-saver中的saveAs</span><br><span class="line"></span><br><span class="line">import &#123;saveAs&#125; from &apos;file-save</span><br><span class="line"></span><br><span class="line">const wbout: string = XLSX.write(wb, &#123;bookType: &apos;xlsx&apos;, bookSST: true, type: &apos;binary&apos;&#125;);</span><br><span class="line"></span><br><span class="line">const s2ab = (s: any) =&gt; &#123;</span><br><span class="line">    const buf = new ArrayBuffer(s.length);</span><br><span class="line">    const view = new Uint8Array(buf);</span><br><span class="line">    for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF;</span><br><span class="line">    return buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">saveAs(new Blob([s2ab(wbout)], &#123;type: &apos;application/octet-stream&apos;&#125;), &apos;sheetJS.xlsx&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>修改某一单元的数据，合并单元格问题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ws: any = XLSX.utils.json_to_sheet(data);</span><br><span class="line">// 修改填充的数据</span><br><span class="line">ws[&apos;A1&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line">ws[&apos;A2&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line">ws[&apos;A3&apos;]=&#123;t: &apos;s&apos;, v: &apos;需要填写的内容&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 合并单元格</span><br><span class="line">/*</span><br><span class="line">c: 代表纵向，从0开始</span><br><span class="line">r: 代表横向，从0开始</span><br><span class="line">*/</span><br><span class="line">ws[&apos;!merges&apos;]=[</span><br><span class="line">    &#123;</span><br><span class="line">    s: &#123;c: 0, r: 0&#125;,</span><br><span class="line">    e: &#123;c: 10, r: 0&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    s: &#123;c: 1, r: 0&#125;,</span><br><span class="line">    e: &#123;c: 1, r: 10&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>单元格</p></blockquote><table><thead><tr><th style="text-align:center">Key</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td style="text-align:center">原始值</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">格式化文本</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">type: b Boolean, e Error, n Number, d Date, s Text, z Stub</td></tr></tbody></table><blockquote><p>多种导出形式</p></blockquote><ul><li>Importing:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aoa_to_sheet converts an array of arrays of JS data to a worksheet.</span><br><span class="line">json_to_sheet converts an array of JS objects to a worksheet.</span><br><span class="line">table_to_sheet converts a DOM TABLE element to a worksheet.</span><br><span class="line">sheet_add_aoa adds an array of arrays of JS data to an existing worksheet.</span><br><span class="line">sheet_add_json adds an array of JS objects to an existing worksheet.</span><br></pre></td></tr></table></figure><ul><li>Exporting:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sheet_to_json converts a worksheet object to an array of JSON objects.</span><br><span class="line">sheet_to_csv generates delimiter-separated-values output.</span><br><span class="line">sheet_to_txt generates UTF16 formatted text.</span><br><span class="line">sheet_to_html generates HTML output.</span><br><span class="line">sheet_to_formulae generates a list of the formulae (with value fallbacks).</span><br></pre></td></tr></table></figure><ul><li>Cell and cell address manipulation:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">format_cell generates the text value for a cell (using number formats).</span><br><span class="line">encode_row / decode_row converts between 0-indexed rows and 1-indexed rows.</span><br><span class="line">encode_col / decode_col converts between 0-indexed columns and column names.</span><br><span class="line">encode_cell / decode_cell converts cell addresses.</span><br><span class="line">encode_range / decode_range converts cell ranges.</span><br></pre></td></tr></table></figure><p><em>其他详细使用，请查看<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">SheetJS</a></em></p>]]></content>
    
    <summary type="html">
    
      SheetJS，JS实现Excel中的数据读取和数据导出。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Excel" scheme="http://blog.juphy.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装nginx</title>
    <link href="http://blog.juphy.com/2018/06/16/centos7%E5%AE%89%E8%A3%85nginx/"/>
    <id>http://blog.juphy.com/2018/06/16/centos7安装nginx/</id>
    <published>2018-06-15T16:00:00.000Z</published>
    <updated>2018-06-20T02:51:43.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过yum安装"><a href="#通过yum安装" class="headerlink" title="通过yum安装"></a>通过yum安装</h2><blockquote><p>直接通过 yum install nginx 肯定是不行的,因为yum没有nginx，所以首先把 nginx 的源加入 yum 中。</p></blockquote><ul><li><p>将nginx放到yum repro库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>查看nginx信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info nginx</span><br></pre></td></tr></table></figure></li><li><p>使用yum安装nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure></li><li><p>查看nginx版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>访问nginx，查看nginx服务返回的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i 公网IP</span><br></pre></td></tr></table></figure></li><li><p>nginx -t：测试配置文件的语法，配置文件是否写得正确，以及配置文件得路径</p></li><li><p>找到nginx文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure></li></ul><h2 id="手动下载安装包"><a href="#手动下载安装包" class="headerlink" title="手动下载安装包"></a>手动下载安装包</h2><ul><li><p>1、下载nginx包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.10.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>2、复制包到安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx-1.10.1.tar.gz /usr/loca</span><br></pre></td></tr></table></figure></li><li><p>3、解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.10.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>4、启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      在centos7中通过两种不同的方式安装nginx。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="linux" scheme="http://blog.juphy.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>数组方法</title>
    <link href="http://blog.juphy.com/2018/04/08/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.juphy.com/2018/04/08/数组方法/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-06-20T03:34:26.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6数组"><a href="#ES6数组" class="headerlink" title="ES6数组"></a>ES6数组</h2><ul><li>Array.from()：用于将两类对象转为真正的数组，类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。<ul><li>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</li><li>第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</li><li>第三个参数，用来绑定this。</li><li>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</li></ul></li><li><p>Array.of()：用于将一组值，转换为数组。弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br><span class="line">Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组</span><br></pre></td></tr></table></figure></li><li><p>copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p></li><li>Array.prototype.copyWithin(target, start = 0, end = this.length)<ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul></li><li>find：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</li><li><p>findIndex：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</span><br><span class="line"></span><br><span class="line">[NaN].indexOf(NaN)</span><br><span class="line">// -1</span><br><span class="line"></span><br><span class="line">[NaN].findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br><span class="line"></span><br><span class="line">indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</span><br></pre></td></tr></table></figure></li><li><p>fill：使用给定值，填充一个数组。fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><ul><li>如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</li></ul></li><li>enties()：键值对的遍历</li><li>keys()：键名的遍历</li><li>values()：键值的遍历</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。</span><br><span class="line">let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">let entries = letter.entries();</span><br><span class="line">console.log(entries.next().value); // [0, &apos;a&apos;]</span><br><span class="line">console.log(entries.next().value); // [1, &apos;b&apos;]</span><br><span class="line">console.log(entries.next().value); // [2, &apos;c&apos;]</span><br></pre></td></tr></table></figure><ul><li>includes：返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。<ul><li>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</li><li>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。[NaN].indexOf(NaN) //-1</li></ul></li><li>Map 和 Set 数据结构有一个has方法，需要注意与includes区分。<ul><li>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</li><li>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</li></ul></li></ul><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><ul><li><p>数组的空位指，数组的某一个位置没有任何值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3) //[,,,]</span><br></pre></td></tr></table></figure></li><li><p>空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 in [undefined, undefined, undefined] // true</span><br><span class="line">0 in [, , ,] // false</span><br></pre></td></tr></table></figure><ul><li><p>ES5对空位的处理，很不一致。</p><ul><li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li><li>map()会跳过空位，但会保留这个值</li><li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// forEach方法</span><br><span class="line">[,&apos;a&apos;].forEach((x,i) =&gt; console.log(i)); // 1</span><br><span class="line"></span><br><span class="line">// filter方法</span><br><span class="line">[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;]</span><br><span class="line"></span><br><span class="line">// every方法</span><br><span class="line">[,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true</span><br><span class="line"></span><br><span class="line">// reduce方法</span><br><span class="line">[1,,2].reduce((x,y) =&gt; return x+y) // 3</span><br><span class="line"></span><br><span class="line">// some方法</span><br><span class="line">[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false</span><br><span class="line"></span><br><span class="line">// map方法</span><br><span class="line">[,&apos;a&apos;].map(x =&gt; 1) // [,1]</span><br><span class="line"></span><br><span class="line">// join方法</span><br><span class="line">[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;</span><br><span class="line"></span><br><span class="line">// toString方法</span><br><span class="line">[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ES6 则是明确将空位转为undefined。</p><ul><li>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</li><li>扩展运算符（…）也会将空位转为undefined。</li><li>copyWithin()会连空位一起拷贝。</li><li>fill()会将空位视为正常的数组位置。</li><li>for…of循环也会遍历空位。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      es6中有关Array的方法和方法。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://blog.juphy.com/tags/ES6/"/>
    
      <category term="Array" scheme="http://blog.juphy.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>数值方法</title>
    <link href="http://blog.juphy.com/2018/03/25/%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.juphy.com/2018/03/25/数值方法/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-06-20T03:34:26.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h2><blockquote><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p></blockquote><blockquote><p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p></blockquote><ul><li><p>Number.isFinite()：用来检查一个数值是否为有限的（finite），即不是Infinity。如果参数类型不是数值，Number.isFinite一律返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(0.8); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br><span class="line">Number.isFinite(Infinity); // false</span><br><span class="line">Number.isFinite(-Infinity); // false</span><br><span class="line">Number.isFinite(&apos;foo&apos;); // false</span><br><span class="line">Number.isFinite(&apos;15&apos;); // false</span><br><span class="line">Number.isFinite(true); // false</span><br></pre></td></tr></table></figure></li><li><p>Number.isNaN()：用来检查一个值是否为NaN。如果参数类型不是数值，Number.isNaN一律返回false。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(15) // false</span><br><span class="line">Number.isNaN(&apos;15&apos;) // false</span><br><span class="line">Number.isNaN(true) // false</span><br><span class="line">Number.isNaN(9/NaN) // true</span><br><span class="line">Number.isNaN(&apos;true&apos; / 0) // true</span><br><span class="line">Number.isNaN(&apos;true&apos; / &apos;true&apos;) // true</span><br></pre></td></tr></table></figure><blockquote><p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false，Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p></blockquote><ul><li>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</li><li>Number.isInteger()用来判断一个数值是否为整数，返回布尔值。JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。如果参数不是数值，Number.isInteger返回false。</li></ul><blockquote><p>由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(3.0000000000000002) // true</span><br><span class="line">Number.isInteger(5E-324) // false</span><br><span class="line">Number.isInteger(5E-325) // true</span><br><span class="line">类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</span><br></pre></td></tr></table></figure><ul><li>Number.EPSILON：根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。<br>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</li><li>Number.MAX_SAFE_INTEGER，Number.MIN_SAFE_INTEGER用来表示整数范围的上下限。</li><li>Number.isSafeInteger()：用来判断一个<code>整数</code>是否落在这个范围之内。</li><li>Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。</li><li><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">它会返回五种值。</span><br><span class="line">参数为正数，返回+1；</span><br><span class="line">参数为负数，返回-1；</span><br><span class="line">参数为 0，返回0；</span><br><span class="line">参数为-0，返回-0;</span><br><span class="line">其他值，返回NaN。</span><br></pre></td></tr></table></figure></code></pre></li><li><p>**：指数运算符。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2**2 // 4</span><br><span class="line">2**3 // 4</span><br><span class="line">a**2 // a*a</span><br><span class="line">b**3 // b*b*b</span><br></pre></td></tr></table></figure></code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      es6中有关Number的方法和属性。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://blog.juphy.com/tags/ES6/"/>
    
      <category term="Number" scheme="http://blog.juphy.com/tags/Number/"/>
    
  </entry>
  
  <entry>
    <title>对象方法</title>
    <link href="http://blog.juphy.com/2018/03/18/%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.juphy.com/2018/03/18/对象方法/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-06-20T03:33:21.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h2><p><em>ES6允许直接写入变量和函数，最为对象的属性和方法。</em></p><ul><li>name：返回函数名 。</li><li>Object.is()：用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</li><li>Object.assign()：用于对象的合并，将原对象的所有可枚举属性，赋值到目标对象。第一个参数是目标对象，后面的参数都是源对象。如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target=&#123;a:1&#125;;</span><br><span class="line">var target1=&#123;b:2&#125;;</span><br><span class="line">var target2=&#123;c:3&#125;;</span><br><span class="line">Object.assign(target,target1,target2)</span><br><span class="line">target // &#123;a:1,b:2,c:3&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果该参数不是对象，则会先转成对象，然后返回。由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><ul><li><p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝自身属性），也不拷贝不可枚举的属性（enumerable:false）。</p><ul><li>1、实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</li><li>2、同名属性替换</li><li><p>3、数组的处理：但是会把数组视为对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([1, 2, 3], [4, 5])</span><br><span class="line">// [4, 5, 3]</span><br></pre></td></tr></table></figure></li><li><p>4、取值函数的处理：Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const source = &#123;</span><br><span class="line">  get foo() &#123; return 1 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const target = &#123;&#125;;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; foo: 1 &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h2><p>描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</p><p>目前，有四个操作会忽略enumerable为false的属性。</p><ul><li>for…in循环：只遍历对象自身的和继承的可枚举的属性。</li><li>Object.keys()：返回对象自身的所有可枚举的属性的键名。</li><li>JSON.stringify()：只串行化对象自身的可枚举的属性。</li><li>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li></ul><h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><ul><li>ES6 一共有 5 种方法可以遍历对象的属性。<ul><li>（1）for…in：for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</li><li>（2）Object.keys(obj)：Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。<br>-（3）Object.getOwnPropertyNames(obj)：Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。<br>-（4）Object.getOwnPropertySymbols(obj)：Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。<br>-（5）Reflect.ownKeys(obj)：Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li></ul></li></ul><blockquote><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p></blockquote><blockquote><p>首先遍历所有数值键，按照数值升序排列。</p></blockquote><blockquote><p>其次遍历所有字符串键，按照加入时间升序排列。</p></blockquote><blockquote><p>最后遍历所有 Symbol 键，按照加入时间升序排列。</p></blockquote>]]></content>
    
    <summary type="html">
    
      es6中有关Object的方法和属性。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://blog.juphy.com/tags/ES6/"/>
    
      <category term="Object" scheme="http://blog.juphy.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>字符串方法</title>
    <link href="http://blog.juphy.com/2018/03/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.juphy.com/2018/03/11/字符串方法/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-06-20T03:34:26.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6字符串方法"><a href="#ES6字符串方法" class="headerlink" title="ES6字符串方法"></a>ES6字符串方法</h2><ul><li>includes： 返回布尔值，表示是否找到了参数字符串</li><li>startsWith：返回布尔值，表示参数字符串是否在原字符串的头部</li><li>endsWisth：返回布尔值，表示参数字符串是否在原字符串的尾部</li></ul><blockquote><p>以上三个方法都支持第二个参数，表示开始搜索的位置，使用第二个参数时，endsWith表示的是针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p></blockquote><ul><li>repeat：返回一个新字符串，表示将原字符串重复n次。string.repeat(n)<ul><li>n=0，返回空字符串</li><li>n是小数，会被向下取整</li><li>n是0到-1之间的小数，则等同于0</li><li>n是负数或者Infinity，则会报错</li><li>NaN等同于0</li><li>n是字符串，则会转换成数字</li></ul></li></ul><ul><li>padStart：返回补全后的字符串，在原字符串前补全</li><li>padEnd：返回补全后的字符串，在原字符串后补全<ul><li>如果某个字符串不够指定长度，会在头部或尾部补全，接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串</li><li>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</li><li>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</li><li>如果省略第二个参数，默认使用空格补全长度。</li><li>常见用途：数值补全指定位数，提示字符串格式</li></ul></li></ul><ul><li>ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</li><li>模板字符串：是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<ul><li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</li><li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。如果不想要换行，可以使用trim()</li><li>模板字符串中嵌入变量，需要将变量名写在${}之中，大括号内部可以放入任意JavaScript表达式，可以进行运算，以及引用对象属性。</li><li>模板字符串之中还能调用函数。</li><li>如果模板字符串中的变量没有声明，将报错。</li></ul></li><li>标签模板：<ul><li>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</li><li>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</li><li>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">alert`123` 相等于 alert(123)</span><br><span class="line"></span><br><span class="line">let a = 5;</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);</span><br><span class="line"></span><br><span class="line">模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</span><br><span class="line">函数tag依次会接收到多个参数。</span><br><span class="line"></span><br><span class="line">function tag(stringArr, value1, value2)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">function tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。函数tag依次会接收到多个参数。</p><p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p><p>tag函数所有参数的实际值如下。</p><ul><li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li><li>第二个参数: 15</li><li>第三个参数：50</li></ul><p>如何将各个参数按照原来的位置拼合回去？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let total = 30;</span><br><span class="line">let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;</span><br><span class="line"></span><br><span class="line">function passthru(literals) &#123;</span><br><span class="line">  let result = &apos;&apos;;</span><br><span class="line">  let i = 0;</span><br><span class="line"></span><br><span class="line">  while (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    if (i &lt; arguments.length) &#123;</span><br><span class="line">      result += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">literals // [ &apos;The total is &apos;, &apos; (&apos;, &apos; with tax)&apos; ]</span><br><span class="line">arguments // &#123; &apos;0&apos;: [ &apos;The total is &apos;, &apos; (&apos;, &apos; with tax)&apos; ],</span><br><span class="line">               &apos;1&apos;: 30,</span><br><span class="line">               &apos;2&apos;: 31.5 &#125;</span><br><span class="line">msg // &quot;The total is 30 (31.5 with tax)&quot;</span><br></pre></td></tr></table></figure><p>passthru函数采用rest函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function passthru(literals, ...values)&#123;</span><br><span class="line">    let output = &quot;&quot;;</span><br><span class="line">    let index;</span><br><span class="line">    for(index = 0; index &lt; values.length; index++)&#123;</span><br><span class="line">        output += literals[index] + values[index];</span><br><span class="line">    &#125;</span><br><span class="line">    output += literals[index];</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的作用：</p><ul><li>过滤 HTML 字符串，防止用户输入恶意内容。</li><li>多语言转换（国际化处理）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let message =</span><br><span class="line">  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">function SaferHTML(templateData) &#123;</span><br><span class="line">  let s = templateData[0];</span><br><span class="line">  for (let i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    let arg = String(arguments[i]);</span><br><span class="line"></span><br><span class="line">    // Escape special characters in the substitution.</span><br><span class="line">    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)</span><br><span class="line">            .replace(/&lt;/g, &quot;&amp;lt;&quot;)</span><br><span class="line">            .replace(/&gt;/g, &quot;&amp;gt;&quot;);</span><br><span class="line"></span><br><span class="line">    // Don&apos;t escape special characters in the template.</span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sender = &apos;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&apos;; // 恶意代码</span><br><span class="line">let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">message</span><br></pre></td></tr></table></figure><ul><li>String.raw()：String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<ul><li>作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</li><li>作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String.raw(&#123; raw: &apos;test&apos; &#125;, 0, 1, 2);</span><br><span class="line">// &apos;t0e1s2t&apos;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">String.raw(&#123; raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] &#125;, 0, 1, 2);</span><br><span class="line"></span><br><span class="line">String.raw = function (strings, ...values) &#123;</span><br><span class="line">  let output = &apos;&apos;;</span><br><span class="line">  let index;</span><br><span class="line">  for (index = 0; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      es6中有关String的方法和属性。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://blog.juphy.com/tags/ES6/"/>
    
      <category term="String" scheme="http://blog.juphy.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>函数方法</title>
    <link href="http://blog.juphy.com/2018/03/04/%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.juphy.com/2018/03/04/函数方法/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-06-20T03:00:37.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</span><br><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure><blockquote><p>参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p></blockquote><blockquote><p>使用参数默认值时，函数不能有同名参数。</p></blockquote><blockquote><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 99;</span><br><span class="line">function foo(p = x + 1) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 100</span><br><span class="line"></span><br><span class="line">x = 100;</span><br><span class="line">foo() // 101</span><br></pre></td></tr></table></figure><h2 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1 2</span><br><span class="line">foo() // TypeError: Cannot read property &apos;x&apos; of undefined</span><br></pre></td></tr></table></figure><blockquote><p>只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x 和 y 都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x 有值，y 无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x 和 y 都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure><h2 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h2><blockquote><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p></blockquote><blockquote><p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">function f(x = 1, y) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">function f(x, y = 5, z) &#123;</span><br><span class="line">  return [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure><h2 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h2><blockquote><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p></blockquote><blockquote><p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">function f(x, y = x) &#123;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(2) // 2</span><br><span class="line">参数y的默认值等于变量x，默认值变量指向第一个参数x，而不是全局变量。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line"></span><br><span class="line">function f(y = x) &#123;</span><br><span class="line">  let x = 2;</span><br><span class="line">  console.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br><span class="line">函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line"></span><br><span class="line">function foo(x = x) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">foo() // ReferenceError: x is not defined</span><br><span class="line">参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let foo = &apos;outer&apos;;</span><br><span class="line"></span><br><span class="line">function bar(func = () =&gt; foo) &#123;</span><br><span class="line">  let foo = &apos;inner&apos;;</span><br><span class="line">  console.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // outer</span><br></pre></td></tr></table></figure><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><blockquote><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p></blockquote><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><blockquote><p>尾调用：某个函数的最后一步是调用另一个函数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以下不属于尾调用：</span><br><span class="line">function f(x)&#123;</span><br><span class="line">  let y = g(x);</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(x)&#123;</span><br><span class="line">  return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(x)&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</span><br><span class="line">函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</span><br></pre></td></tr></table></figure><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><blockquote><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</span><br><span class="line">这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</span><br><span class="line">- func.arguments：返回调用时函数的参数。</span><br><span class="line">- func.caller：返回调用当前函数的那个函数。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      es6中有关函数的方法和属性。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://blog.juphy.com/tags/ES6/"/>
    
      <category term="Function" scheme="http://blog.juphy.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>数组基础</title>
    <link href="http://blog.juphy.com/2017/02/11/%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.juphy.com/2017/02/11/数组基础/</id>
    <published>2017-02-10T16:00:00.000Z</published>
    <updated>2018-06-20T03:34:26.891Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了 Object 之外， Array 类型恐怕是 ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p></blockquote><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><ul><li><p>构造函数模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); //创建一个包含 3 项，即字符串red&quot;, &quot;blue&quot;, &quot;green&quot;的数组</span><br><span class="line">var colors = new Array(3); // 创建一个包含 3 项的数组，实际项目中，很少有人这么写；</span><br><span class="line">var colors = Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); //构造函数的new是可以省略的；</span><br></pre></td></tr></table></figure></li><li><p>数组字面量表示法<br>数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</span><br><span class="line">var names = []; // 创建一个空数组</span><br><span class="line">var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组</span><br><span class="line">var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组；在其他浏览器中， values 会成为一个包含 2项且值分别为1 和 2 的数组。原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。由于这个bug导致的另一种情况如最后一行代码所示，该行代码可能会创建包含 5 项的数组（在 IE9+、Firefox、Opera、Safari 和 Chrome 中），也可能会创建包含 6 项的数组（在 IE8 及更早版本中）。在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。但是由于 IE 的实现与其他浏览器不一致，因此强烈建议不要使用这种语法。</p></blockquote><p>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，如下所示：<strong>数组的索引是以0开始的,一定要注意</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 定义一个字符串数组</span><br><span class="line">console.log(colors[0]); // 显示第一项,可以思考下，如果访问的索引超过数组长度呢？会返回什么</span><br><span class="line">colors[2] = &quot;black&quot;; // 修改第三项</span><br><span class="line">colors[3] = &quot;brown&quot;; // 新增第四项,如果设置某个值的索引超过了数组现有项数,数组就会自动增加到该索引值加 1 的长度（就这个例子而言，索是 3，因此数组长度就是 4）</span><br></pre></td></tr></table></figure></p><h2 id="数组的length属性"><a href="#数组的length属性" class="headerlink" title="数组的length属性"></a>数组的length属性</h2><p>数组的项数保存在其 length 属性中，这个属性始终会返回 0 或更大的值，如下面这个例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</span><br><span class="line">var names = []; // 创建一个空数组</span><br><span class="line">console.log(colors.length); //3</span><br><span class="line">console.log(names.length); //0</span><br></pre></td></tr></table></figure><ul><li><p>数组的 length 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  // 创建一个包含 3 个字符串的数组</span><br><span class="line">colors.length = 2;</span><br><span class="line">console.log(colors[2]); //undefined，此时的colors数组已经被改变了；数组 colors 一开始有 3 个值。将其 length 属性设置为 2 会移除最后一项（位置为2 的那一项），结果再访问 colors[2] 就会显示 undefined 了。</span><br><span class="line">colors.length = 10;</span><br><span class="line">console.log(colors[9]); //undefined,虽然 colors 数组包含 2 个项，但把它的 length 属性设置成了 10。这个数组不存在位置 9，所以访问这个位置的值就得到了特殊值 undefined 。</span><br></pre></td></tr></table></figure></li><li><p>利用 length 属性也可以方便地在数组末尾添加新项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</span><br><span class="line">colors[colors.length] = &quot;black&quot;; // （在位置 3 ）添加一种颜色</span><br><span class="line">colors[colors.length] = &quot;brown&quot;; // （在位置 4 )再添加一种颜色</span><br><span class="line">```</span><br><span class="line">&gt; 由于数组最后一项的索引始终是 length-1 ，因此下一个新项的位置就是 length 。每当在数组末尾添加一项后，其 length 属性都会自动更新以反应这一变化。</span><br><span class="line"></span><br><span class="line">**数组中的小技巧**</span><br><span class="line"></span><br><span class="line">获取或者修改数组的长度，例如：ary.length = ary.length-1就是删除数组的最后一项；数组中的splice相对来说实现删除的时候，每删除一项后面的索引都需要重新的计算，比较耗费性能，如果要删除数组中所谓为n这一项，我们可以这样去写： </span><br><span class="line">```      </span><br><span class="line">ary[n]=ary[ary.length-1];//首先把数组的最后一项替换当前的项</span><br><span class="line">ary.length=ary.length-1;//然后在删除数组的最后一项</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ul><li>array[index] ;直接数组后面跟[索引]即可；</li></ul><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><ul><li><code>push</code> 向数组末尾增加新元素，返回新增后数组的长度，原有的数组改变；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary=[];</span><br><span class="line">ary.push(12);</span><br><span class="line">```  </span><br><span class="line">- `pop` 删除数组末尾的元素，返回删除的内容，原有的数组改变；</span><br></pre></td></tr></table></figure></li></ul><p>var ary=[1，2，3，4];<br>ary.pop();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `shift` 删除数组第一位元素，返回删除后的内容，原有的数组改变；</span><br></pre></td></tr></table></figure></p><p>var ary=[1，2，3，4];<br>ary.shift();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `unshift` 向数组开头增加新元素，返回新增后数组的长度，原有的数组改变；</span><br></pre></td></tr></table></figure></p><p>var ary=[];<br>ary.unshift(12);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `splice`</span><br></pre></td></tr></table></figure></p><p>splice(n,m)   从索引n开始删除m个元素，把删除的部分当作新数组返回，原有的数组改变<br>splice(n,m,x) 从索引n开始删除m个元素，把删除的部分当作新数组返回，并且用x替换原来位置的内容，原有的数组改变<br>splice(n,0,x) 把x添加到指定索引n之前；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `slice`</span><br></pre></td></tr></table></figure></p><p>slice(n,m)    从索引n开找到索引m处(不包含m)，将找到的内容放到新数组返回，原有的数组不变<br>slice(n)      从索引n处一直找到数组末尾；<br>slice(0)      数组克隆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `concat`  将两个数组进行拼接，原有数组不变</span><br></pre></td></tr></table></figure></p><p>ary1.concat(ary2)<br>ary1.concat() 相当于clice(0)也是克隆数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- `join`  将数组按照指定的分隔符拆分字符串，原有的数组不变</span><br><span class="line">- `toString`  将数组转化为字符串，原有的数组不变</span><br><span class="line">- `sort`  数组排序的方法，原有数组改变，我们通常这样写，ary.sort(function(a,b)&#123;return a-b;&#125;);来实现数组的升序排列 </span><br><span class="line">- `reverse`  将数组倒过来排序，原来数组改变</span><br><span class="line">- `indexOf / lastIndexOf`  获取数组中某一项的索引，通常用来检测数组中是否包含某一项内容，不包含返回的是-1；这个方法在IE678下不兼容；</span><br><span class="line">- `forEach`  循环数组中每一项，然后进行相关的操作，这个方法在IE678不兼容，</span><br></pre></td></tr></table></figure></p><p>ary.forEach(function(item,index,input){},context);第二个参数是指定函数中的this，不写默认是window<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `map`  循环数组中的每一项，然后进行相关的操作，相对于forEach来说，map有返回值，可以修改数组中某一项，IE678不兼容，</span><br></pre></td></tr></table></figure></p><p>ary.map(function(item,index,input){},context);第二个参数是指定函数中的this，不写默认是window<br><code>`</code>  </p><ul><li><code>length</code>  返回数组的长度</li></ul>]]></content>
    
    <summary type="html">
    
      数组基础知识。
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.juphy.com/categories/JavaScript/"/>
    
    
      <category term="Array" scheme="http://blog.juphy.com/tags/Array/"/>
    
  </entry>
  
</feed>
